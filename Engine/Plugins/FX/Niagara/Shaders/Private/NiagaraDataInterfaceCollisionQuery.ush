// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "NiagaraRayTracingCommon.ush"

#define NDICOLLISIONQUERY_USE_GBUFFER_NORMAL    (FEATURE_LEVEL >= FEATURE_LEVEL_SM5)

float NDICollisionQuery_GetCustomSceneDepth(float2 ScreenUV)
{
#if (FEATURE_LEVEL <= FEATURE_LEVEL_ES3_1)
	return ConvertFromDeviceZ(Texture2DSampleLevel(MobileSceneTextures.CustomDepthTexture, MobileSceneTextures.CustomDepthTextureSampler, ScreenUV, 0).r);
#else
	return ConvertFromDeviceZ(Texture2DSampleLevel(SceneTexturesStruct.CustomDepthTexture, SceneTexturesStruct_CustomDepthTextureSampler, ScreenUV, 0).r);
#endif
}

void NDICollisionQuery_QuerySceneDepthGPU(in float3 In_SamplePos, in float3 In_LWCTile, out float Out_SceneDepth, out float3 Out_CameraPosWorld, out bool Out_IsInsideView, out float3 Out_WorldPos, out float3 Out_WorldNormal)
{
	Out_SceneDepth = -1;
	Out_WorldPos = float3(0.0, 0.0, 0.0);
	Out_WorldNormal = float3(0.0, 0.0, 1.0);
	Out_IsInsideView = true;
	FLWCVector3 CameraPos = PrimaryView.WorldCameraOrigin;
	LWCSetTile(CameraPos, LWCGetTile(CameraPos) - In_LWCTile); // convert to simulation space
	Out_CameraPosWorld = LWCToFloat(CameraPos);

	FLWCVector3 LwcSamplePos = MakeLWCVector3(In_LWCTile, In_SamplePos);
	float4 SamplePosition = float4(LWCToFloat(LWCAdd(LwcSamplePos, PrimaryView.PreViewTranslation)), 1); // TODO[mg]: LWCToFloat here?
	float4 ClipPosition = mul(SamplePosition, View.TranslatedWorldToClip);
	float2 ScreenPosition = ClipPosition.xy / ClipPosition.w;

	// Check if the sample is inside the view.
	if (all(abs(ScreenPosition.xy) <= float2(1, 1)))
	{
		// Sample the depth buffer to get a world position near the sample position.
		float2 ScreenUV = ScreenPosition * View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz;
		float SceneDepth = CalcSceneDepth(ScreenUV);
		FLWCVector3 WorldPosition = WorldPositionFromSceneDepth(ScreenPosition.xy, SceneDepth);

#if NDICOLLISIONQUERY_USE_GBUFFER_NORMAL
		float3 WorldNormal = Texture2DSampleLevel(SceneTexturesStruct.GBufferATexture, SceneTexturesStruct_GBufferATextureSampler, ScreenUV, 0).xyz * 2.0 - 1.0;
#else
		float CollisionDepthBounds = 500.0f;
		float SceneDepth0 = CalcSceneDepth(ScreenUV + float2(View.BufferSizeAndInvSize.z, 0.0));
		float SceneDepth1 = CalcSceneDepth(ScreenUV + float2(0.0, View.BufferSizeAndInvSize.w));
		// When using the forward shading, the normal of the pixel is approximated by the derivative of the world position
		// of the pixel. But in on the visible edge this derivative can become very high, making CollisionPlane almost
		// perpendicular to the view plane. In these case the particle may collide the visible edges of the diferent meshes
		// in the view frustum. To avoid this, we disable the collision test if one of the derivate is above a threshold.
		if (max(abs(SceneDepth - SceneDepth0), abs(SceneDepth - SceneDepth1)) > CollisionDepthBounds)
		{
			return;
		}

		FLWCVector3 WorldPosition0 = WorldPositionFromSceneDepth(ScreenPosition.xy + float2(2 * View.ViewSizeAndInvSize.z, 0.0), SceneDepth0);
		FLWCVector3 WorldPosition1 = WorldPositionFromSceneDepth(ScreenPosition.xy - float2(0.0, 2 * View.ViewSizeAndInvSize.w), SceneDepth1);
		float3 WorldNormal = normalize(cross(LWCSubtract(WorldPosition0, WorldPosition).Offset, LWCSubtract(WorldPosition1, WorldPosition).Offset));
#endif

		// convert LWC position back to simulation space
		LWCSetTile(WorldPosition, LWCGetTile(WorldPosition) - In_LWCTile);
		
		// Set outputs
		Out_SceneDepth = SceneDepth;
		Out_WorldPos = LWCToFloat(WorldPosition);
		Out_WorldNormal = WorldNormal;
	}
	else
	{
		Out_IsInsideView = false;
	}
}

void NDICollisionQuery_QueryCustomDepthGPU(in float3 In_SamplePos, in float3 In_LWCTile, out float Out_SceneDepth, out float3 Out_CameraPosWorld, out bool Out_IsInsideView, out float3 Out_WorldPos, out float3 Out_WorldNormal)
{
	Out_SceneDepth = -1;
	Out_WorldPos = float3(0.0, 0.0, 0.0);
	Out_WorldNormal = float3(0.0, 0.0, 1.0);
	Out_IsInsideView = true;
	FLWCVector3 CameraPos = PrimaryView.WorldCameraOrigin;
	LWCSetTile(CameraPos, LWCGetTile(CameraPos) - In_LWCTile); // convert to simulation space
	Out_CameraPosWorld = LWCToFloat(CameraPos);

	FLWCVector3 LwcSamplePos = MakeLWCVector3(In_LWCTile, In_SamplePos);
	float4 SamplePosition = float4(LWCToFloat(LWCAdd(LwcSamplePos, PrimaryView.PreViewTranslation)), 1); // TODO[mg]: LWCToFloat here?
	float4 ClipPosition = mul(SamplePosition, View.TranslatedWorldToClip);
	float2 ScreenPosition = ClipPosition.xy / ClipPosition.w;

	// Check if the sample is inside the view.
	if (all(abs(ScreenPosition.xy) <= float2(1, 1)))
	{
		// Sample the depth buffer to get a world position near the sample position.
		float2 ScreenUV = ScreenPosition * View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz;
		float SceneDepth = NDICollisionQuery_GetCustomSceneDepth(ScreenUV);
		FLWCVector3 WorldPosition = WorldPositionFromSceneDepth(ScreenPosition.xy, SceneDepth);

#if NDICOLLISIONQUERY_USE_GBUFFER_NORMAL
		float3 WorldNormal = Texture2DSampleLevel(SceneTexturesStruct.GBufferATexture, SceneTexturesStruct_GBufferATextureSampler, ScreenUV, 0).xyz * 2.0 - 1.0;
#else
		float CollisionDepthBounds = 500.0f;
		float SceneDepth0 = NDICollisionQuery_GetCustomSceneDepth(ScreenUV + float2(View.BufferSizeAndInvSize.z, 0.0));
		float SceneDepth1 = NDICollisionQuery_GetCustomSceneDepth(ScreenUV + float2(0.0, View.BufferSizeAndInvSize.w));
		// When using the forward shading, the normal of the pixel is approximated by the derivative of the world position
		// of the pixel. But in on the visible edge this derivative can become very high, making CollisionPlane almost
		// perpendicular to the view plane. In these case the particle may collide the visible edges of the diferent meshes
		// in the view frustum. To avoid this, we disable the collision test if one of the derivate is above a threshold.
		if (max(abs(SceneDepth - SceneDepth0), abs(SceneDepth - SceneDepth1)) > CollisionDepthBounds)
		{
			return;
		}

		FLWCVector3 WorldPosition0 = WorldPositionFromSceneDepth(ScreenPosition.xy + float2(2 * View.ViewSizeAndInvSize.z, 0.0), SceneDepth0);
		FLWCVector3 WorldPosition1 = WorldPositionFromSceneDepth(ScreenPosition.xy - float2(0.0, 2 * View.ViewSizeAndInvSize.w), SceneDepth1);
		float3 WorldNormal = normalize(cross(LWCSubtract(WorldPosition0, WorldPosition).Offset, LWCSubtract(WorldPosition1, WorldPosition).Offset));
#endif

		// convert LWC position back to simulation space
		LWCSetTile(WorldPosition, LWCGetTile(WorldPosition) - In_LWCTile);
		
		// Set outputs
		Out_SceneDepth = SceneDepth;
		Out_WorldPos = LWCToFloat(WorldPosition);
		Out_WorldNormal = WorldNormal;
	}
	else
	{
		Out_IsInsideView = false;
	}
}

void NDICollisionQuery_QueryMeshDistanceFieldGPU(in float3 In_SamplePos, in float3 In_LWCTile, out float Out_DistanceToNearestSurface, out float3 Out_FieldGradient, out bool Out_IsDistanceFieldValid)
{
#if PLATFORM_SUPPORTS_DISTANCE_FIELDS && (FEATURE_LEVEL >= FEATURE_LEVEL_SM5)
	FLWCVector3 LwcSamplePos = MakeLWCVector3(In_LWCTile, In_SamplePos);
	float3 SamplePosition = LWCToFloat(LwcSamplePos); // TODO: remove LWCToFloat here when GetDistanceToNearestSurfaceGlobal supports LWC
	
	Out_DistanceToNearestSurface = GetDistanceToNearestSurfaceGlobal(SamplePosition);
	Out_FieldGradient = GetDistanceFieldGradientGlobal(SamplePosition);
	Out_IsDistanceFieldValid = (MaxGlobalDFAOConeDistance > 0) && !(Out_DistanceToNearestSurface > 0 && all(Out_FieldGradient == float3(0,0,0.001f)));
#else
	Out_DistanceToNearestSurface = 0;
	Out_FieldGradient = (float3)0;
	Out_IsDistanceFieldValid = false;
#endif
}

#if NIAGARA_USE_RAYTRACING

uint BuildRayTraceMask(int TraceChannel)
{
	// for now we'll ignore the TraceChannel till we can mark up the environment
	return 0xFF;
}

void NDICollisionQuery_IssueAsyncRayTrace(uint MaxRayTraceCount, RWStructuredBuffer<FNiagaraRayData> RWRayRequests, uint RayRequestOffset, RWBuffer<uint> RWRayTraceCounts, uint RayTraceCountsOffset, float3 In_LWCTile, int In_QueryID, float3 In_TraceStart, float3 In_TraceEnd, int In_TraceChannel, out bool Out_IsQueryValid)
{
	Out_IsQueryValid = false;

	if (In_QueryID >= 0 && uint(In_QueryID) < MaxRayTraceCount)
	{
		FLWCVector3 LwcStartPos = MakeLWCVector3(In_LWCTile, In_TraceStart);
		FLWCVector3 LwcEndPos = MakeLWCVector3(In_LWCTile, In_TraceEnd);
		
		float3 Trace = LWCToFloat(LWCSubtract(LwcEndPos, LwcStartPos));
		float TraceLength = length(Trace);

		//Offset query into the actual ray buffer.
		uint RayIndex = RayRequestOffset + In_QueryID;
		RWRayRequests[RayIndex].Origin = LWCToFloat(LwcStartPos); // TODO: remove LWCToFloat here when FNiagaraRayData supports LWC
		RWRayRequests[RayIndex].Mask = BuildRayTraceMask(In_TraceChannel);
		RWRayRequests[RayIndex].Direction = normalize(Trace);
		RWRayRequests[RayIndex].TFar = TraceLength;
		Out_IsQueryValid = true;

		// we want to keep track of the maximum index used
		InterlockedMax(RWRayTraceCounts[RayTraceCountsOffset + 0], In_QueryID + 1);
		RWRayTraceCounts[RayTraceCountsOffset + 1] = 1;
		RWRayTraceCounts[RayTraceCountsOffset + 2] = 1;
	}
}

void NDICollisionQuery_ReserveRayTraceIndex(uint MaxRayTraceCount, RWBuffer<uint> RWRayTraceCounts, uint RayTraceCountsOffset, int In_TraceCount, out int Out_StartQueryID, out bool Out_IndicesValid)
{
	Out_IndicesValid = false;

	if ((In_TraceCount + RWRayTraceCounts[RayTraceCountsOffset + 0]) < MaxRayTraceCount)
	{
		uint RequestIndex = 0;
		InterlockedAdd(RWRayTraceCounts[RayTraceCountsOffset + 0], In_TraceCount, RequestIndex);
		RWRayTraceCounts[RayTraceCountsOffset + 1] = 1;
		RWRayTraceCounts[RayTraceCountsOffset + 2] = 1;

		if ((In_TraceCount + RequestIndex) <= MaxRayTraceCount)
		{
			Out_StartQueryID = int(RequestIndex);
			Out_IndicesValid = true;
		}
		else
		{
			InterlockedMax(RWRayTraceCounts[RayTraceCountsOffset + 0], MaxRayTraceCount);
		}
	}
}

void NDICollisionQuery_CreateAsyncRayTrace(	uint MaxRayTraceCount, RWStructuredBuffer<FNiagaraRayData> RWRayRequests, uint RayRequestsOffset, RWBuffer<uint> RWRayTraceCounts, uint RayTraceCountsOffset, float3 In_LWCTile,
											float3 In_TraceStart, float3 In_TraceEnd, int In_TraceChannel, out int Out_QueryID, out bool Out_IsQueryValid)
{
	Out_IsQueryValid = false;

	NDICollisionQuery_ReserveRayTraceIndex(MaxRayTraceCount, RWRayTraceCounts, RayTraceCountsOffset, 1, Out_QueryID, Out_IsQueryValid);

	if (Out_IsQueryValid)
	{
		FLWCVector3 LwcStartPos = MakeLWCVector3(In_LWCTile, In_TraceStart);
		FLWCVector3 LwcEndPos = MakeLWCVector3(In_LWCTile, In_TraceEnd);
		
		float3 Trace = LWCToFloat(LWCSubtract(LwcEndPos, LwcStartPos));
		float TraceLength = length(Trace);

		uint RayIndex = Out_QueryID + RayRequestsOffset;
		RWRayRequests[RayIndex].Origin = LWCToFloat(LwcStartPos); // TODO: remove LWCToFloat here when FNiagaraRayData supports LWC
		RWRayRequests[RayIndex].Mask = BuildRayTraceMask(In_TraceChannel);
		RWRayRequests[RayIndex].Direction = normalize(Trace);
		RWRayRequests[RayIndex].TFar = TraceLength;

		//TODO: We can pack collision group and trace channels into the same int and test both in the RG Shader.
		RWRayRequests[RayIndex].CollisionGroup = In_TraceChannel;
	}
}

void NDICollisionQuery_ReadAsyncRayTrace(uint MaxRayTraceCount, StructuredBuffer<FNiagaraRayTracingResult> IntersectionResults, uint IntersectionRestultsOffest, float3 In_LWCTile, int In_PreviousFrameQueryID, out bool Out_CollisionValid, out float Out_CollisionDistance, out float3 Out_CollisionPosWorld, out float3 Out_CollisionNormal)
{
	Out_CollisionValid = false;
	Out_CollisionDistance = 0.0f;
	Out_CollisionPosWorld = float3(0.0f, 0.0f, 0.0f);
	Out_CollisionNormal = float3(0.0f, 0.0f, 0.0f);

	if (In_PreviousFrameQueryID >= 0 && uint(In_PreviousFrameQueryID) < MaxRayTraceCount)
	{
		FNiagaraRayTracingResult HitResult = IntersectionResults[In_PreviousFrameQueryID + IntersectionRestultsOffest];

		Out_CollisionValid = HitResult.IsHit();
		if (Out_CollisionValid)
		{
			Out_CollisionDistance = HitResult.HitT;
			Out_CollisionPosWorld = LWCToFloat(MakeLWCVector3(-In_LWCTile, HitResult.WorldPosition)); // TODO: HitResult.WorldPosition should support LWC properly
			Out_CollisionNormal = HitResult.WorldNormal;
		}
	}
}

#endif