// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"        

FStrataData StrataConvertLegacyMaterial(
	float3 BaseColor, float Specular, float Metallic,
	float Roughness, float Anisotropy,
	float3 SubSurfaceColor, float SubSurfaceProfileId,
	float ClearCoat, float ClearCoatRoughness,
	float3 Emissive,
	float Opacity, 
	float3 TransmittanceColor,
	float3 WaterScatteringCoefficients, float3 WaterAbsorptionCoefficients, float WaterPhaseG, float3 ColorScaleBehindWater,
	uint ShadingModel,
	uint SharedLocalBasisIndex,
	uint ClearCoatBottomNormal_SharedLocalBasisIndex,
	inout uint SharedLocalBasisTypes)
{
	FStrataData Out = GetInitialisedStrataData();

	const float DefaultThickness = STRATA_LAYER_DEFAULT_THICKNESS_CM;
	const float3 Zeros = float3(0, 0, 0);
	const float3 Ones  = float3(1, 1, 1);
	if (ShadingModel == SHADINGMODELID_UNLIT)
	{
		Out = GetStrataUnlitBSDF(Emissive, Ones /*TransnmittanceColor*/);
	}
	else if (ShadingModel == SHADINGMODELID_DEFAULT_LIT)
	{
		Out = GetStrataSlabBSDF(
			true,				// UseMetalness
			BaseColor,			// BaseColor		-  Metalness workflow
			Ones,				// EdgeColor		-  Metalness workflow
			Specular,			// Specular			-  Metalness workflow
			Metallic,			// Metallic			-  Metalness workflow
			Zeros,				// DiffuseAlbedo	- !Metalness workflow
			Zeros, 				// F0				- !Metalness workflow
			Zeros,				// F90				- !Metalness workflow
			Roughness,			// Roughness
			Anisotropy,			// Anisotropy
			0.f,				// SSSProfileID
			Zeros,				// SSSDMFP
			0.f,				// SSSDMFPScale
			Emissive,			// Emissive
			0.f,				// Haziness
			0.f,				// ThinFilmThickness
			0.f,				// FuzzAmount
			Zeros,				// FuzzColor
			DefaultThickness,
			SharedLocalBasisIndex, SharedLocalBasisTypes);

		// Take in account the legacy opacity weighting for translucent material
		#if !MATERIALBLENDING_MASKED && !MATERIALBLENDING_SOLID
		{
			Out = StrataWeight(Out, Opacity);
		}
		#endif
	}
	else if (ShadingModel == SHADINGMODELID_SUBSURFACE || ShadingModel == SHADINGMODELID_PREINTEGRATED_SKIN)
	{
		// Subsurface model has a subsurface color and a base color which are additive through normal warpping. 
		// We emulate that by adding them together
		const float3 ModifiedBaseColor = BaseColor + SubSurfaceColor;

		// For Subsurface and Pre-integrated subsurface opacity acts as lerp between SSS (0) and Opaque(1), 
		// so we need to (saturate and) inverse with a OneMinus node.
		float3 SSSMFP = 1.f - saturate(Opacity);

		// Subsurface color is converted into a MFP by taking the subsurface color and multipling it with the 1-Opacity 
		// and a constant scaling for matching roughly the behavior
		SSSMFP = SSSMFP * 0.5f;

		Out = GetStrataSlabBSDF(
			true,				// UseMetalness
			ModifiedBaseColor,	// BaseColor		-  Metalness workflow
			Ones,				// EdgeColor		-  Metalness workflow
			Specular,			// Specular			-  Metalness workflow
			Metallic,			// Metallic			-  Metalness workflow
			Zeros,				// DiffuseAlbedo	- !Metalness workflow
			Zeros, 				// F0				- !Metalness workflow
			Zeros,				// F90				- !Metalness workflow
			Roughness,			// Roughness
			Anisotropy,			// Anisotropy
			0.f,				// SSSProfileID
			SSSMFP,				// SSSDMFP
			Opacity,			// SSSDMFPScale
			Emissive,			// Emissive
			0.f,				// Haziness
			0.f,				// ThinFilmThickness
			0.f,				// FuzzAmount
			Zeros,				// FuzzColor
			DefaultThickness,
			SharedLocalBasisIndex, SharedLocalBasisTypes);

		// No need to take into account opacity weighting for translucent material, as the coverage is assumed to be 1
	}
	else if (ShadingModel == SHADINGMODELID_SUBSURFACE_PROFILE)
	{
		Out = GetStrataSlabBSDF(
			true,				// UseMetalness
			BaseColor,			// BaseColor		-  Metalness workflow
			Ones,				// EdgeColor		-  Metalness workflow
			Specular,			// Specular			-  Metalness workflow
			Metallic,			// Metallic			-  Metalness workflow
			Zeros,				// DiffuseAlbedo	- !Metalness workflow
			Zeros, 				// F0				- !Metalness workflow
			Zeros,				// F90				- !Metalness workflow
			Roughness,			// Roughness
			Anisotropy,			// Anisotropy
			SubSurfaceProfileId,// SSSProfileID
			Zeros,				// SSSDMFP
			Opacity,			// SSSDMFPScale
			Emissive,			// Emissive
			0.f,				// Haziness
			0.f,				// ThinFilmThickness
			0.f,				// FuzzAmount
			Zeros,				// FuzzColor
			DefaultThickness,
			SharedLocalBasisIndex, SharedLocalBasisTypes);

		// No need to take into account opacity weighting for translucent material, as the coverage is assumed to be 1
	}
	else if (ShadingModel == SHADINGMODELID_CLEAR_COAT)
	{
		// === BOTTOM layer === 

		FStrataData BottomSlab = GetStrataSlabBSDF(
			true,				// UseMetalness
			BaseColor,			// BaseColor		-  Metalness workflow
			Ones,				// EdgeColor		-  Metalness workflow
			Specular,			// Specular			-  Metalness workflow
			Metallic,			// Metallic			-  Metalness workflow
			Zeros,				// DiffuseAlbedo	- !Metalness workflow
			Zeros, 				// F0				- !Metalness workflow
			Zeros,				// F90				- !Metalness workflow
			Roughness,			// Roughness
			Anisotropy,			// Anisotropy
			0.f,				// SSSProfileID
			Zeros,				// SSSDMFP
			0.f,				// SSSDMFPScale
			Zeros,				// Emissive
			0.f,				// Haziness
			0.f,				// ThinFilmThickness
			0.f,				// FuzzAmount
			Zeros,				// FuzzColor
			DefaultThickness,
			ClearCoatBottomNormal_SharedLocalBasisIndex, /*ClearCoatBottomNormal_*/SharedLocalBasisTypes); // TODO normally we should be able to flag the bottom layer as anisotropic
		
		// === TOP layer === 
		 																								   
		// The top layer has a hard coded specular value of 0.5 (F0 = 0.04)
		// BaseColor = 0 to only feature absorption, no scattering

		// The original clear coat is a complex assemblage of arbitrary functions that do not always make sense. 
		// To simplify things, we set the top slab BSDF as having a constant Grey scale transmittance. 
		// As for the original, this is achieved with coverage so both transmittance and specular contribution vanishes

		// Now setup the mean free path with a hard coded transmittance of 0.75 when viewing the surface perpendicularly
		const float Thickness = DefaultThickness;
		const float3 MFP = TransmittanceToMeanFreePath(0.75f, Thickness * CENTIMETER_TO_METER) * METER_TO_CENTIMETER;

		FStrataData TopSlab = GetStrataSlabBSDF(
			true,				// UseMetalness
			Zeros,				// BaseColor		-  Metalness workflow
			Ones,				// EdgeColor		-  Metalness workflow
			0.5f,				// Specular			-  Metalness workflow
			0.f,				// Metallic			-  Metalness workflow
			Zeros,				// DiffuseAlbedo	- !Metalness workflow
			Zeros, 				// F0				- !Metalness workflow
			Zeros,				// F90				- !Metalness workflow
			ClearCoatRoughness, // Roughness
			Anisotropy,			// Anisotropy
			0.f,				// SSSProfileID
			MFP,				// SSSDMFP
			1.f,				// SSSDMFPScale
			Emissive,			// Emissive
			0.f,				// Haziness
			0.f,				// ThinFilmThickness
			0.f,				// FuzzAmount
			Zeros,				// FuzzColor
			Thickness,
			SharedLocalBasisIndex, SharedLocalBasisTypes);

		// === Layering === 
		FStrataData WeightedTopSlab = StrataWeight(TopSlab, ClearCoat);
		Out = StrataVerticalLayering(WeightedTopSlab, BottomSlab);

		// Take in account the legacy opacity weighting for translucent material
		#if !MATERIALBLENDING_MASKED && !MATERIALBLENDING_SOLID
		{
			Out = StrataWeight(Out, Opacity);
		}
		#endif
	}
	else if (ShadingModel == SHADINGMODELID_TWOSIDED_FOLIAGE)
	{
	// Set a thickness that will enabled the thin lighting model (corresponding to the legacy two-sided lighting model)
		const float Thickness = STRATA_LAYER_ISTHIN_THICKNESS_THRESHOLD_CM - 1e-5f;
		const float3 MFP = TransmittanceToMeanFreePath(SubSurfaceColor /*TransmittanceColor*/, Thickness * CENTIMETER_TO_METER) * METER_TO_CENTIMETER;

		Out = GetStrataSlabBSDF(
			true,				// UseMetalness
			BaseColor,			// BaseColor		-  Metalness workflow
			Ones,				// EdgeColor		-  Metalness workflow
			Specular,			// Specular			-  Metalness workflow
			Metallic,			// Metallic			-  Metalness workflow
			Zeros,				// DiffuseAlbedo	- !Metalness workflow
			Zeros, 				// F0				- !Metalness workflow
			Zeros,				// F90				- !Metalness workflow
			Roughness,			// Roughness
			Anisotropy,			// Anisotropy
			0.f,				// SSSProfileID
			MFP,				// SSSDMFP
			1.f,				// SSSDMFPScale
			Emissive,			// Emissive
			0.f,				// Haziness
			0.f,				// ThinFilmThickness
			0.f,				// FuzzAmount
			Zeros,				// FuzzColor
			Thickness,
			SharedLocalBasisIndex, SharedLocalBasisTypes);

		// Take in account the legacy opacity weighting for translucent material
		#if !MATERIALBLENDING_MASKED && !MATERIALBLENDING_SOLID
		{
			Out = StrataWeight(Out, Opacity);
		}
		#endif
	}
	else if (ShadingModel == SHADINGMODELID_HAIR)
	{
		Out = GetStrataHairBSDF(
			BaseColor,	   // BaseColor
			Metallic,	   // Scatter
			Specular,	   // Specular
			Roughness,	   // Roughness
			ClearCoat,	   // Backlit
			Emissive,		// EmissiveColor
			SharedLocalBasisIndex);

		// No need to take into account opacity weighting for translucent material, as the coverage is assumed to be 1
	}
	else if (ShadingModel == SHADINGMODELID_CLOTH)
	{
		Out = GetStrataSlabBSDF(
			true,				// UseMetalness
			BaseColor,			// BaseColor		-  Metalness workflow
			Ones,				// EdgeColor		-  Metalness workflow
			Specular,			// Specular			-  Metalness workflow
			Metallic,			// Metallic			-  Metalness workflow
			Zeros,				// DiffuseAlbedo	- !Metalness workflow
			Zeros, 				// F0				- !Metalness workflow
			Zeros,				// F90				- !Metalness workflow
			Roughness,			// Roughness
			Anisotropy,			// Anisotropy
			0.f,				// SSSProfileID
			0.f,				// SSSDMFP
			0.f,				// SSSDMFPScale
			Emissive,			// Emissive
			0.f,				// Haziness
			0.f,				// ThinFilmThickness
			ClearCoat,			// FuzzAmount
			SubSurfaceColor,	// FuzzColor
			DefaultThickness,
			SharedLocalBasisIndex, SharedLocalBasisTypes);

		// Take in account the legacy opacity weighting for translucent material
		#if !MATERIALBLENDING_MASKED && !MATERIALBLENDING_SOLID
		{
			Out = StrataWeight(Out, Opacity);
		}
		#endif
	}
	else if (ShadingModel == SHADINGMODELID_EYE)
	{
		const float IrisMask = ClearCoat;
		const float IrisDistance = ClearCoatRoughness;
		const float IrisOpacity = saturate(1.0f - IrisMask);

		// Incorrect composition, but allows to compile shaders
		{
			const float3 TopBaseColor = BaseColor; // lerp(BaseColor, Zeros, IrisMask);

			FStrataData CoatSlab = GetStrataSlabBSDF(
				true,				// UseMetalness
				TopBaseColor,		// BaseColor		-  Metalness workflow
				Ones,				// EdgeColor		-  Metalness workflow
				Specular,			// Specular			-  Metalness workflow
				0.f,				// Metallic			-  Metalness workflow
				Zeros,				// DiffuseAlbedo	- !Metalness workflow
				Zeros, 				// F0				- !Metalness workflow
				Zeros,				// F90				- !Metalness workflow
				Roughness,			// Roughness
				0.f,				// Anisotropy
				SubSurfaceProfileId,// SSSProfileID
				Zeros,				// SSSDMFP
				Opacity,			// SSSDMFPScale
				Emissive,			// Emissive
				0.f,				// Haziness
				0.f,				// ThinFilmThickness
				0.f,				// FuzzAmount
				Zeros,				// FuzzColor
				DefaultThickness,
				SharedLocalBasisIndex, SharedLocalBasisTypes);

			FStrataData IrisSlab = GetStrataSlabBSDF(
				true,				// UseMetalness
				BaseColor,			// BaseColor		-  Metalness workflow
				Ones,				// EdgeColor		-  Metalness workflow
				Specular,			// Specular			-  Metalness workflow
				0.f,				// Metallic			-  Metalness workflow
				Zeros,				// DiffuseAlbedo	- !Metalness workflow
				Zeros, 				// F0				- !Metalness workflow
				Zeros,				// F90				- !Metalness workflow
				Roughness,			// Roughness
				0.f,				// Anisotropy
				SubSurfaceProfileId,// SSSProfileID
				Zeros,				// SSSDMFP
				Opacity,			// SSSDMFPScale
				Emissive,			// Emissive
				0.f,				// Haziness
				0.f,				// ThinFilmThickness
				0.f,				// FuzzAmount
				Zeros,				// FuzzColor
				DefaultThickness,
				ClearCoatBottomNormal_SharedLocalBasisIndex, /*ClearCoatBottomNormal_*/SharedLocalBasisTypes);

			Out = StrataVerticalLayering(CoatSlab, IrisSlab);
		}
		// No need to take into account opacity weighting for translucent material, as the coverage is assumed to be 1
	}
	else if (ShadingModel == SHADINGMODELID_SINGLELAYERWATER)
	{
		const float3 WaterExtinction = WaterScatteringCoefficients + WaterAbsorptionCoefficients;
		const float3 WaterAlbedo = WaterScatteringCoefficients / WaterExtinction;

		Out = GetStrataSingleLayerWaterBSDF(
			BaseColor, 				// BaseColor
			Metallic, 				// Metallic 
			Specular, 				// Specular
			Roughness, 				// Roughness 
			Emissive, 				// Emissive 
			Opacity,				// TopMaterialOpacity
			WaterAlbedo, 			// WaterAlbedo
			WaterExtinction, 		// WaterExtinction
			WaterPhaseG, 			// WaterPhaseG
			ColorScaleBehindWater,	// ColorScaleBehindWater
			SharedLocalBasisIndex);

		// No need to take into account opacity weighting for translucent material, as the coverage is assumed to be 1
	}
	else if (ShadingModel == SHADINGMODELID_THIN_TRANSLUCENT)	
	{
		// Top slab BSDF as a simple Disney material
		FStrataData TopSlab = GetStrataSlabBSDF(
			true,				// UseMetalness
			BaseColor,			// BaseColor		-  Metalness workflow
			Ones,				// EdgeColor		-  Metalness workflow
			Specular,			// Specular			-  Metalness workflow
			Metallic,			// Metallic			-  Metalness workflow
			Zeros,				// DiffuseAlbedo	- !Metalness workflow
			Zeros, 				// F0				- !Metalness workflow
			Zeros,				// F90				- !Metalness workflow
			Roughness,			// Roughness
			Anisotropy,			// Anisotropy
			0.f,				// SSSProfileID
			Zeros,				// SSSDMFP
			0.f,				// SSSDMFPScale
			Emissive,			// Emissive
			0.f,				// Haziness
			0.f,				// ThinFilmThickness
			0.f,				// FuzzAmount
			Zeros,				// FuzzColor
			DefaultThickness,
			SharedLocalBasisIndex, SharedLocalBasisTypes);

		// Now weight the top base material by opacity
		FStrataData WeightedTopSlab = StrataWeight(TopSlab, Opacity);

		// Bottom slab BSDF will be a simple absorption only layer
		const bool bHasTransmittance = any(TransmittanceColor > 0.f);
		if (bHasTransmittance)
		{
			const float Thickness = DefaultThickness;
			const float3 MFP = TransmittanceToMeanFreePath(TransmittanceColor, Thickness * CENTIMETER_TO_METER) * METER_TO_CENTIMETER;

			// Assign specular properties shared with the top layer.
			FStrataData BottomSlab = GetStrataSlabBSDF(
				true,				// UseMetalness
				Zeros,	// BaseColor		-  Metalness workflow
				Ones,				// EdgeColor		-  Metalness workflow
				Specular,			// Specular			-  Metalness workflow
				0.f,				// Metallic			-  Metalness workflow
				Zeros,				// DiffuseAlbedo	- !Metalness workflow
				Zeros, 				// F0				- !Metalness workflow
				Zeros,				// F90				- !Metalness workflow
				Roughness,			// Roughness
				0.f,				// Anisotropy
				0.f,				// SSSProfileID
				MFP,				// SSSDMFP
				1.f,				// SSSDMFPScale
				Zeros,				// Emissive
				0.f,				// Haziness
				0.f,				// ThinFilmThickness
				0.f,				// FuzzAmount
				Zeros,				// FuzzColor
				Thickness,
				SharedLocalBasisIndex, SharedLocalBasisTypes);

			Out = StrataVerticalLayering(WeightedTopSlab, BottomSlab);
		}
		else
		{
			Out = TopSlab;
		}

		// No need to take into account opacity weighting for translucent material, as the coverage is assumed to be 1
	}
	return Out;
}