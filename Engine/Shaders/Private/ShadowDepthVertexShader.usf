// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	ShadowDepthVertexShader.usf: Vertex & Geometry shader for writing shadow depth.
=============================================================================*/

// needs to before Common.usf
#define SHADOW_DEPTH_SHADER 1
#define USE_STENCIL_LOD_DITHER	0

#ifndef ENABLE_NON_NANITE_VSM
#error "ENABLE_NON_NANITE_VSM should be defined to either 0 or 1!"
#endif


#if ENABLE_NON_NANITE_VSM
	#define VIRTUAL_SM_ENABLED (!(ONEPASS_POINTLIGHT_SHADOW || PERSPECTIVE_CORRECT_DEPTH))
#else
	#define VIRTUAL_SM_ENABLED 0
#endif

// Need to get the definition of nanite packed view for generated unform buffer (which is pulled in by Common.ush)
#include "Nanite/PackedNaniteView.ush"
#include "Common.ush"

// Reroute SceneTexturesStruct uniform buffer references to the shadow depth pass uniform buffer
#if FEATURE_LEVEL >= FEATURE_LEVEL_SM5
#define PassStruct ShadowDepthPass
#define SceneTexturesStruct ShadowDepthPass.SceneTextures 
#else
#define PassStruct MobileShadowDepthPass
#define MobileSceneTextures MobileShadowDepthPass.SceneTextures 
#endif

#include "/Engine/Generated/Material.ush"
#include "/Engine/Generated/VertexFactory.ush"
#include "ShadowDepthCommon.ush"


#if VIRTUAL_SM_ENABLED
#include "Nanite/NaniteDataDecode.ush"
#include "SceneData.ush"
#include "VirtualShadowMaps/PageAccessCommon.ush"
#endif // VIRTUAL_SM_ENABLED


void SetShadowDepthOutputs(
	float4x4 WorldToClipMatrix, 
	float4x4 WorldToShadowMatrix, 
	float4 WorldPosition, 
	float3 WorldVertexNormal, 
	out float4 OutPosition, 
	out float ShadowDepth
#if PERSPECTIVE_CORRECT_DEPTH
	, out float OutDepthBias
#endif
)
{
	OutPosition = mul(WorldPosition, WorldToClipMatrix);

	// Clamp the vertex to the near plane if it is in front of the near plane
	// This has problems if some vertices of a triangle get clamped and others do not, also causes artifacts with non-ortho projections
	if (PassStruct.bClampToNearPlane > 0 && OutPosition.z > OutPosition.w)
	{
		OutPosition.z = 0.999999f;
		OutPosition.w = 1.0f;
	}

	#if ONEPASS_POINTLIGHT_SHADOW
	const float3 ViewDirection = -normalize(mul(WorldPosition, WorldToShadowMatrix).xyz);
	const float3 ViewNormal = mul(float4(WorldVertexNormal,0), WorldToShadowMatrix).xyz;
	const float NoL = abs(dot(ViewDirection, ViewNormal));
	#else
	const float NoL = abs(dot(
		float3(WorldToShadowMatrix[0].z, WorldToShadowMatrix[1].z, WorldToShadowMatrix[2].z),
		WorldVertexNormal));
	#endif

	const float MaxSlopeDepthBias = PassStruct.ShadowParams.z;
	const float Slope = clamp(abs(NoL) > 0 ? sqrt(saturate(1 - NoL*NoL)) / NoL : MaxSlopeDepthBias, 0, MaxSlopeDepthBias);
	
	const float SlopeDepthBias = PassStruct.ShadowParams.y;
	const float SlopeBias = SlopeDepthBias * Slope;

	const float ConstantDepthBias = PassStruct.ShadowParams.x;
	const float DepthBias = SlopeBias + ConstantDepthBias;

	#if PERSPECTIVE_CORRECT_DEPTH
		ShadowDepth = OutPosition.z;
		OutDepthBias = DepthBias;
	#elif ONEPASS_POINTLIGHT_SHADOW
		ShadowDepth = 0;
		//OutPosition.z += DepthBias;
	#else
		// Output linear, normalized depth
		const float InvMaxSubjectDepth = PassStruct.ShadowParams.w;
		#if PLATFORM_NEEDS_PRECISE_SHADOW_DEPTH
			precise 
		#endif
		float AdjustedDepth = ( 1 - OutPosition.z * InvMaxSubjectDepth ) + DepthBias;
		ShadowDepth = AdjustedDepth;
		OutPosition.z = AdjustedDepth;
	#endif
}

/** 
 * Load physical page offset and perform the needed scale and bias to render the instance into the given physical page,
 * with the correct clipping set up.
 */
#if VIRTUAL_SM_ENABLED

FPageInfo UnPackPageInfo(uint PackedData)
{
	// TODO: Why not do address translation here? Physical pages need fewer bits.
	uint4 PackedData4 = 0U;
	PackedData4.x = PackedData;
	uint BitPos = 0U;
	FPageInfo PageInfo;
	PageInfo.VirtualPage.x = ReadBits(PackedData, BitPos, VSM_LOG2_LEVEL0_DIM_PAGES_XY);
	PageInfo.VirtualPage.y = ReadBits(PackedData, BitPos, VSM_LOG2_LEVEL0_DIM_PAGES_XY);
	PageInfo.ViewId = ReadBits(PackedData, BitPos, VSM_PACKED_PAGE_INFO_VIEW_ID_BITS);

	return PageInfo;
}

void ScaleBiasClipToPhysicalSmPage(FNaniteView NaniteView, inout float4 PositionClip, inout float4 ClipPlanesInOut, FPageInfo PageInfo)
{
	uint2 vPage = PageInfo.VirtualPage;

	float2 vClip = PositionClip.xy;
	float2 vUV = vClip * float2(0.5, -0.5) + 0.5 * PositionClip.w;
	float2 vPixels = vUV * ( uint(VSM_VIRTUAL_MAX_RESOLUTION_XY) >> NaniteView.TargetMipLevel );

	{
		//PointClip.xy = NaniteView.ClipSpaceScaleOffset.xy * PointClip.xy + NaniteView.ClipSpaceScaleOffset.zw * PointClip.w;

		float2 Scale = exp2( -NaniteView.TargetMipLevel );
		PositionClip.xy *= Scale;
		PositionClip.xy += ( Scale * float2(1,-1) + float2(-1,1) ) * PositionClip.w;
	}

	{
		// Clip to allocated page rect
		uint4 PageRect = PassStruct.PageRectBounds[ NaniteView.TargetLayerIndex * VSM_MAX_MIP_LEVELS + NaniteView.TargetMipLevel ];

		float2 MinClip =  vPixels - ( PageRect.xy + 0 ) * VSM_PAGE_SIZE * PositionClip.w;
		float2 MaxClip = -vPixels + ( PageRect.zw + 1 ) * VSM_PAGE_SIZE * PositionClip.w;

		ClipPlanesInOut.xy = MinClip;
		ClipPlanesInOut.zw = MaxClip;
	}
}

void TransformToVirtualSmPage(inout float4 PointClip, inout float4 ClipPlanesInOut, FPageInfo PageInfo, float3 PointTranslatedWorld)
{
	// Load nanite view and perform transform to SM space.
	FNaniteView NaniteView = UnpackNaniteView(PassStruct.PackedNaniteViews[PageInfo.ViewId]);

	PointTranslatedWorld += ( -LWCHackToFloat(ResolvedView.PreViewTranslation) + LWCHackToFloat(NaniteView.PreViewTranslation) );
	PointClip = mul( float4( PointTranslatedWorld, 1 ), NaniteView.TranslatedWorldToClip );

	// Clamp the vertex to the near plane if it is in front of the near plane
	// This has problems if some vertices of a triangle get clamped and others do not, also causes artifacts with non-ortho projections
	if (PassStruct.bClampToNearPlane > 0 && PointClip.z > PointClip.w)
	{
		PointClip.z = 0.999999f;
		PointClip.w = 1.0f;
	}

	ScaleBiasClipToPhysicalSmPage(NaniteView, PointClip, ClipPlanesInOut, PageInfo);
}

#endif // VIRTUAL_SM_ENABLED


#if FEATURE_LEVEL >= FEATURE_LEVEL_SM4 && ONEPASS_POINTLIGHT_SHADOW

// Layer Id per draw call for Vertex-Shader-Layer implementation
#if VERTEXSHADER && USING_VERTEX_SHADER_LAYER
uint LayerId;
#endif

uint bUseGpuSceneInstancing;

struct FShadowDepthGSToPS
{
#if INTERPOLATE_VF_ATTRIBUTES
	FShadowDepthVSToPS PSInputs;
#endif
	float4 OutPosition : SV_POSITION;

	/** Controls which of the cube map faces to rasterize the primitive to, only the value from the first vertex is used. */
	uint RTIndex : SV_RenderTargetArrayIndex;
};

bool IsTriangleInFrustum(float4 ClipSpacePositions[3])
{
	float4 FrustumTests0 = saturate(ClipSpacePositions[0].xyxy * float4(-1, -1, 1, 1) - ClipSpacePositions[0].w);
	float4 FrustumTests1 = saturate(ClipSpacePositions[1].xyxy * float4(-1, -1, 1, 1) - ClipSpacePositions[1].w);
	float4 FrustumTests2 = saturate(ClipSpacePositions[2].xyxy * float4(-1, -1, 1, 1) - ClipSpacePositions[2].w);
	float4 FrustumTests = FrustumTests0 * FrustumTests1 * FrustumTests2;

	float2 FrustumTestsZ0 = saturate(ClipSpacePositions[0].zz * float2(-1, 1) - ClipSpacePositions[0].w);
	float2 FrustumTestsZ1 = saturate(ClipSpacePositions[1].zz * float2(-1, 1) - ClipSpacePositions[1].w);
	float2 FrustumTestsZ2 = saturate(ClipSpacePositions[2].zz * float2(-1, 1) - ClipSpacePositions[2].w);
	float2 FrustumTestsZ = FrustumTestsZ0 * FrustumTestsZ1 * FrustumTestsZ2;
	return !( any(FrustumTests != 0) || any(FrustumTestsZ != 0) );
}

/** Allocate space for cloning to all 6 faces which is the worst case (no GPU-scene active). */
/** GPU-Scene case: Instancing takes care of the clone, we just route to a layer. */
[maxvertexcount(18)]
void MainOnePassPointLightGS(triangle FShadowDepthVSToGS Input[3], inout TriangleStream<FShadowDepthGSToPS> OutStream)
{
#if ENABLE_FALLBACK_POINTLIGHT_SHADOW_GS
	uint CubeFaceStartIndex = bUseGpuSceneInstancing ? Input[0].ViewIndex : 0;
	uint CubeFaceEndIndex = bUseGpuSceneInstancing ? Input[0].ViewIndex + 1: 6;

	// Clone the triangle to each face
	for (int CubeFaceIndex = CubeFaceStartIndex; CubeFaceIndex < CubeFaceEndIndex; CubeFaceIndex++)
#else //!ENABLE_FALLBACK_POINTLIGHT_SHADOW_GS
	UNROLL
	// Clone the triangle to each face
	for (int CubeFaceIndex = 0; CubeFaceIndex < 6; CubeFaceIndex++)
#endif // ENABLE_FALLBACK_POINTLIGHT_SHADOW_GS
	{
		float4 ClipSpacePositions[3];
		UNROLL
		for (int VertexIndex = 0; VertexIndex < 3; VertexIndex++)
		{
			// Calculate the clip space position for each cube face
			// Note: We don't apply any constant/slop bias here. A constant bias is applied in the shadow projection 
			// code (see CubemapHardwarePCF() in ShadowProjectionCommon.ush)
			// If one want to use this code path, don't forget to remove the bias in CubemapHardwarePCF().
			#if 0
			const float4 WorldPosition = Input[VertexIndex].GSPosition;
			const float3 WorldVertexNormal = Input[VertexIndex].WorldNormal;
			
			float4 ClipSpacePosition;
			float ShadowDepth;
			SetShadowDepthOutputs(
				PassStruct.ShadowViewProjectionMatrices[CubeFaceIndex],
				PassStruct.ShadowViewMatrices[CubeFaceIndex], 
				WorldPosition, 
				WorldVertexNormal, 
				ClipSpacePosition, 
				ShadowDepth);
			ClipSpacePositions[VertexIndex] = ClipSpacePosition;
			#else
			ClipSpacePositions[VertexIndex] = mul(Input[VertexIndex].GSPosition, PassStruct.ShadowViewProjectionMatrices[CubeFaceIndex]);
			#endif
		}
		// Frustum culling, saves GPU time with high poly meshes
		BRANCH
		if (IsTriangleInFrustum(ClipSpacePositions))
		{
			FShadowDepthGSToPS Output;
			Output.RTIndex = CubeFaceIndex;

			UNROLL
			for (int VertexIndex = 0; VertexIndex < 3; VertexIndex++)
			{
				Output.OutPosition = ClipSpacePositions[VertexIndex];

			#if INTERPOLATE_VF_ATTRIBUTES
				Output.PSInputs.FactoryInterpolants = Input[VertexIndex].FactoryInterpolants;
			#endif

			#if INTERPOLATE_POSITION
				Output.PSInputs.PixelPosition = Input[VertexIndex].GSPosition.xyz;
			#endif
				OutStream.Append(Output);
			}
			OutStream.RestartStrip();
		}
	}
}

#endif

void Main(
	FVertexFactoryInput Input,
#if ONEPASS_POINTLIGHT_SHADOW
  #if IS_FOR_GEOMETRY_SHADER
	out FShadowDepthVSToGS OutParameters,
  #else
	out FShadowDepthVSToPS OutParameters,
  #endif
#if FEATURE_LEVEL >= FEATURE_LEVEL_SM4 && USING_VERTEX_SHADER_LAYER
	out uint LayerIndex : SV_RenderTargetArrayIndex,
#endif
#else
	out FShadowDepthVSToPS OutParameters,
#endif
#if VIRTUAL_SM_ENABLED
	out nointerpolation uint ViewId : TEXCOORD8,
#endif
	out float4 OutPosition : SV_POSITION
#if VIRTUAL_SM_ENABLED	
	// OLA-TODO: this collides with instanced stereo, which thankfully is not used with shadow maps, so should be fine, presumably.
	, out float4 OutVirtualSmPageClip : SV_ClipDistance
#endif // VIRTUAL_SM_ENABLED
	)
{
	ResolvedView = ResolveView();
	
	FVertexFactoryIntermediates VFIntermediates = GetVertexFactoryIntermediates(Input);
	float4 WorldPos = VertexFactoryGetWorldPosition(Input, VFIntermediates);
	float3x3 TangentToLocal = VertexFactoryGetTangentToLocal(Input, VFIntermediates);

	FMaterialVertexParameters VertexParameters = GetMaterialVertexParameters(Input, VFIntermediates, WorldPos.xyz, TangentToLocal);
	const float3 WorldNormal = VertexFactoryGetWorldNormal(Input, VFIntermediates);

	WorldPos.xyz += GetMaterialWorldPositionOffset(VertexParameters);

#if ONEPASS_POINTLIGHT_SHADOW

	OutPosition = WorldPos;

	#if IS_FOR_GEOMETRY_SHADER
		OutParameters.GSPosition = WorldPos;
		OutParameters.WorldNormal = WorldNormal;
		#if ENABLE_FALLBACK_POINTLIGHT_SHADOW_GS
			OutParameters.ViewIndex = VertexFactoryGetViewIndex(VFIntermediates);
		#endif // ENABLE_FALLBACK_POINTLIGHT_SHADOW_GS
	#endif // IS_FOR_GEOMETRY_SHADER

	#if INTERPOLATE_VF_ATTRIBUTES
		// Masked materials need texture coords to clip
		OutParameters.FactoryInterpolants = VertexFactoryGetInterpolantsVSToPS(Input, VFIntermediates, VertexParameters);
	#endif

	#if INTERPOLATE_POSITION
		OutParameters.PixelPosition = WorldPos.xyz;
	#endif

	#if FEATURE_LEVEL >= FEATURE_LEVEL_SM4 && USING_VERTEX_SHADER_LAYER && VERTEXSHADER
		LayerIndex = bUseGpuSceneInstancing ? VertexFactoryGetViewIndex(VFIntermediates) : LayerId;
		OutPosition = mul(WorldPos, PassStruct.ShadowViewProjectionMatrices[LayerIndex]);
		#if INTERPOLATE_VF_ATTRIBUTES && IS_FOR_GEOMETRY_SHADER
			OutParameters.GSPosition = OutPosition;
		#endif
	#endif

#else
	float Dummy;

	SetShadowDepthOutputs(
		PassStruct.ProjectionMatrix,
		PassStruct.ViewMatrix,
		WorldPos, 
		WorldNormal,
		OutPosition, 
#if !PERSPECTIVE_CORRECT_DEPTH
		Dummy
#else
		OutParameters.ShadowDepth,
		OutParameters.DepthBias
#endif
		);
	
	#if INTERPOLATE_VF_ATTRIBUTES
		// Masked materials need texture coords to clip
		OutParameters.FactoryInterpolants = VertexFactoryGetInterpolantsVSToPS(Input, VFIntermediates, VertexParameters);
	#endif

	#if INTERPOLATE_POSITION
		OutParameters.PixelPosition = WorldPos.xyz;
	#endif

	#if !PERSPECTIVE_CORRECT_DEPTH && !COMPILER_SUPPORTS_EMPTY_STRUCTS
		OutParameters.Dummy = 0;
	#endif

#endif

#if VIRTUAL_SM_ENABLED
	ViewId = 0;
	
	OutVirtualSmPageClip = float4(1.0f, 1.0f, 1.0f, 1.0f);
	if (PassStruct.bRenderToVirtualShadowMap != 0)
	{
		// Get the offset from which we loaded the instance ID
		uint InstanceIdIndex = VertexFactoryGetInstanceIdLoadIndex(VFIntermediates);
		FPageInfo PageInfo = UnPackPageInfo(InstanceCulling.PageInfoBuffer[InstanceIdIndex]);

		TransformToVirtualSmPage(OutPosition, OutVirtualSmPageClip, PageInfo, WorldPos.xyz);
		
		ViewId = PageInfo.ViewId;
	}
#endif // VIRTUAL_SM_ENABLED
}

#if IS_FOR_GEOMETRY_SHADER

// Vertex shader exports must match GS inputs.
// This is a requirement on some platforms.
void MainForGS(
	FVertexFactoryInput Input,
#if ONEPASS_POINTLIGHT_SHADOW
	out FShadowDepthVSToGS OutParameters
	#if FEATURE_LEVEL >= FEATURE_LEVEL_SM4 && USING_VERTEX_SHADER_LAYER
		, out uint LayerIndex : SV_RenderTargetArrayIndex
	#endif
#else
	#error Invalid permutation for MainForGS
#endif
#if COMPILER_METAL
#define SKIP_UNUSED_POSITION
	// Metal needs a position output
	, out float4 UnusedPosition : SV_POSITION
#endif
	)
{
#ifndef SKIP_UNUSED_POSITION
	float4 UnusedPosition;
#endif

	Main(Input,
		OutParameters,
#if FEATURE_LEVEL >= FEATURE_LEVEL_SM4 && ONEPASS_POINTLIGHT_SHADOW && USING_VERTEX_SHADER_LAYER
		LayerIndex,
#endif
		UnusedPosition);
}

#endif // IS_FOR_GEOMETRY_SHADER

#define USING_ONEPASS_POINT_VERTEX_LAYER	(FEATURE_LEVEL >= FEATURE_LEVEL_SM4 && ONEPASS_POINTLIGHT_SHADOW && USING_VERTEX_SHADER_LAYER)

#if POSITION_ONLY
void PositionOnlyMain(
	in FPositionAndNormalOnlyVertexFactoryInput Input,
#if USING_ONEPASS_POINT_VERTEX_LAYER
	out uint LayerIndex : SV_RenderTargetArrayIndex,
#endif
#if ONEPASS_POINTLIGHT_SHADOW
	out FShadowDepthVSToGS OutParameters,
#else
	out FShadowDepthVSToPS OutParameters,
#endif
#if VIRTUAL_SM_ENABLED
	out nointerpolation uint ViewId : TEXCOORD8,
#endif
	out float4 OutPosition : SV_POSITION
#if VIRTUAL_SM_ENABLED	
	// OLA-TODO: this collides with instanced stereo, which thankfully is not used with shadow maps, so should be fine, presumably.
	, out float4 OutVirtualSmPageClip : SV_ClipDistance
#endif // VIRTUAL_SM_ENABLED
	)
{
	ResolvedView = ResolveView();

	float4 WorldPos = VertexFactoryGetWorldPosition(Input);

#if INTERPOLATE_VF_ATTRIBUTES
	OutParameters.FactoryInterpolants = (FVertexFactoryInterpolantsVSToPS)0;
#endif

	float3 WorldNormal = VertexFactoryGetWorldNormal(Input);

#if ONEPASS_POINTLIGHT_SHADOW
	OutPosition = OutParameters.GSPosition = WorldPos;
	OutParameters.WorldNormal = WorldNormal;
#if ENABLE_FALLBACK_POINTLIGHT_SHADOW_GS
	OutParameters.ViewIndex = VertexFactoryGetViewIndex(Input);
#endif // !ENABLE_FALLBACK_POINTLIGHT_SHADOW_GS

	#if USING_ONEPASS_POINT_VERTEX_LAYER
		LayerIndex = bUseGpuSceneInstancing ? VertexFactoryGetViewIndex(Input) : LayerId;
		OutPosition = mul(WorldPos, PassStruct.ShadowViewProjectionMatrices[LayerIndex]);
		#if INTERPOLATE_VF_ATTRIBUTES
			OutParameters.GSPosition = OutPosition;
		#endif
	#endif

#else // #if ONEPASS_POINTLIGHT_SHADOW
	float ShadowDepth;
	SetShadowDepthOutputs(
		PassStruct.ProjectionMatrix, 
		PassStruct.ViewMatrix, 
		WorldPos, 
		WorldNormal, 
		OutPosition,
	#if PERSPECTIVE_CORRECT_DEPTH
		OutParameters.ShadowDepth,
		OutParameters.DepthBias
	#else
		ShadowDepth
	#endif
	);

	#if !PERSPECTIVE_CORRECT_DEPTH && !COMPILER_SUPPORTS_EMPTY_STRUCTS
		OutParameters.Dummy = 0;
	#endif
#endif // #if ONEPASS_POINTLIGHT_SHADOW

#if INTERPOLATE_POSITION
	OutParameters.PixelPosition = WorldPos.xyz;
#endif

#if VIRTUAL_SM_ENABLED
	ViewId = 0;

	OutVirtualSmPageClip = float4(1.0f, 1.0f, 1.0f, 1.0f);
	if (PassStruct.bRenderToVirtualShadowMap != 0)
	{
		// Get the offset from which we loaded the instance ID
		uint InstanceIdIndex = VertexFactoryGetInstanceIdLoadIndex(Input);
		// TODO: Maybe offset index to local buffer for this? We may not want to use a global since most passes are not supporting this
		//       Or perhaps both are different, as they are managed somewhat differently anyway, maybe.
		FPageInfo PageInfo = UnPackPageInfo(InstanceCulling.PageInfoBuffer[InstanceIdIndex]);
		TransformToVirtualSmPage(OutPosition, OutVirtualSmPageClip, PageInfo, WorldPos.xyz);

		ViewId = PageInfo.ViewId;
	}
#endif // VIRTUAL_SM_ENABLED
}


#if IS_FOR_GEOMETRY_SHADER

// Vertex shader exports must match GS inputs.
// This is a requirement on some platforms.
void PositionOnlyMainForGS(
	in FPositionAndNormalOnlyVertexFactoryInput Input,
#if USING_ONEPASS_POINT_VERTEX_LAYER
	out uint LayerIndex : SV_RenderTargetArrayIndex,
#endif
#if ONEPASS_POINTLIGHT_SHADOW
	out FShadowDepthVSToGS OutParameters
#else
	#error Invalid permutation for PositionOnlyMainForGS
#endif
#if COMPILER_METAL
	#ifndef SKIP_UNUSED_POSITION
		#define SKIP_UNUSED_POSITION
	#endif
	// Metal needs a position output
	, out float4 UnusedPosition : SV_POSITION
#endif
	)
{
#ifndef SKIP_UNUSED_POSITION
	float4 UnusedPosition;
#endif

	PositionOnlyMain(Input,
#if USING_ONEPASS_POINT_VERTEX_LAYER
		LayerIndex,
#endif
		OutParameters, UnusedPosition);
}

#endif // IS_FOR_GEOMETRY_SHADER

#endif // POSITION_ONLY
