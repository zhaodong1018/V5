// Copyright Epic Games, Inc. All Rights Reserved.

#include "TSRCommon.ush"


//------------------------------------------------------- CONFIG

#define CONFIG_OUTPUT_HALF_RES DIM_OUTPUT_HALF_RES

#define TILE_SIZE 16


//------------------------------------------------------- PARAMETERS

Texture2D<taa_half> ParallaxRejectionMaskTexture;
Texture2D<taa_half3> FilteredInputTexture;
Texture2D<taa_half3> FilteredPredictionSceneColorTexture;
Texture2D<taa_half4> FilteredInterferenceSeedTexture;
Texture2D<taa_half> InterferenceWeightTexture;

RWTexture2D<taa_half> HistoryRejectionOutput;


//------------------------------------------------------- LDS

groupshared taa_half SharedRejection[TILE_SIZE * TILE_SIZE];


//------------------------------------------------------- FUNCTIONS

taa_half3 TransformColorForClampingBox(taa_half3 Color)
{
	return RGBToYCoCg(Color);
}


//------------------------------------------------------- ENTRY POINT

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void MainCS(
	uint2 GroupId : SV_GroupID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	float4 Debug = 0.0;

	taa_short2 InputPixelPos = (
		taa_short2(InputPixelPosMin) +
		taa_short2(GroupId) * taa_short2(TILE_SIZE, TILE_SIZE) +
		Map16x16Tile2x2Lane(GroupThreadIndex));

	taa_half3 InputMinColor;
	taa_half3 InputMaxColor;
	taa_half3 InputCenterColor;
	taa_half ParallaxRejectionMask;
	taa_half InterferenceWeight;
	
	taa_half ClosestInterferenceSeedMin;
	taa_half ClosestInterferenceSeedMax;
	taa_half IntegratedInterferenceSeed;
	taa_half IntegratedInterferenceSeedMin;
	taa_half IntegratedInterferenceSeedMax;
	taa_half MinInterferenceSeed;
	taa_half MaxInterferenceSeed;

	{
		InputCenterColor = TransformColorForClampingBox(FilteredInputTexture[InputPixelPos]);
		ParallaxRejectionMask = ParallaxRejectionMaskTexture[InputPixelPos];

		InputMinColor = InputCenterColor;
		InputMaxColor = InputCenterColor;
		
		InterferenceWeight = InterferenceWeightTexture[InputPixelPos];
		
		taa_half4 InterferenceSeed = FilteredInterferenceSeedTexture[InputPixelPos];
		
		ClosestInterferenceSeedMin = InterferenceSeed.x;
		ClosestInterferenceSeedMax = InterferenceSeed.x; 
		IntegratedInterferenceSeed = InterferenceSeed.y;
		IntegratedInterferenceSeedMin = InterferenceSeed.y;
		IntegratedInterferenceSeedMax = InterferenceSeed.y;
		MinInterferenceSeed = InterferenceSeed.z;
		MaxInterferenceSeed = InterferenceSeed.w;
	}
	
	taa_half NeigborMaxInterferenceSeedGradient = 0.0;
	
	UNROLL
	for (uint i = 0; i < 9; i++)
	{
		if (i == 4)
		{
			continue;
		}
		
		taa_short2 SampleInputPixelPos = InputPixelPos + ClampPixelOffset(
			InputPixelPos,
			kOffsets3x3[i], kOffsets3x3[i],
			InputPixelPosMin, InputPixelPosMax);

		taa_half3 Color = TransformColorForClampingBox(FilteredInputTexture[SampleInputPixelPos]);
		taa_half4 InterferenceSeed = FilteredInterferenceSeedTexture[SampleInputPixelPos];

		InputMinColor = min(InputMinColor, Color);
		InputMaxColor = max(InputMaxColor, Color);
		
		taa_half InterferenceSeedGradient = InterferenceSeed.w - InterferenceSeed.z;
		
		ClosestInterferenceSeedMin = min(ClosestInterferenceSeedMin, InterferenceSeed.x);
		ClosestInterferenceSeedMax = max(ClosestInterferenceSeedMax, InterferenceSeed.x); 
		
		// TODO(TSR): this is InterferenceSeed.w - InterferenceSeed.z
		IntegratedInterferenceSeedMin = min(IntegratedInterferenceSeedMin, InterferenceSeed.y);
		IntegratedInterferenceSeedMax = max(IntegratedInterferenceSeedMax, InterferenceSeed.y);
		
		NeigborMaxInterferenceSeedGradient = max(NeigborMaxInterferenceSeedGradient, InterferenceSeedGradient); 
	}
	
	bool bIsInterference = false;
	#if DIM_MOIRE_HEURISTIC
	{
		// Error due to the low bitdepth of the inteference seeds in the history.
		const taa_half InterferenceSeedEncodingError = rcp(taa_half(SUPERRES_INTERFERENCE_BITMASK));

		taa_half InputSeedMin = LumaToInterferenceSeed(InputMinColor.x);
		taa_half InputSeedMax = LumaToInterferenceSeed(InputMaxColor.x);

		// Measure the low frequency gradien in the seed. Needs to happen both on current frame input to avoid ghosting on
		// current frame changes with high contrast geometric edges, and previous frames to avoid ghosting on area that had 
		// high contrast geometric edges but no longer had in current frame due to shading change.
		taa_half InterferenceSeedGradient = max(InputSeedMax - InputSeedMin, IntegratedInterferenceSeedMax - IntegratedInterferenceSeedMin);
		//taa_half InterferenceSeedGradient = InputSeedMax - InputSeedMin;

		// Detect if there is any inteference based on any subpixel detail range from the lowest LDR to highest LDR.
		bool bRejectInterferenceSeedWithGradient = (
			1 && (MinInterferenceSeed < ClosestInterferenceSeedMin - InterferenceSeedEncodingError - InterferenceSeedGradient) ||
			1 && (MaxInterferenceSeed > ClosestInterferenceSeedMax + InterferenceSeedEncodingError + InterferenceSeedGradient));
			
		bool bRejectInterferenceSeed = (
			(MinInterferenceSeed < ClosestInterferenceSeedMin - InterferenceSeedEncodingError) ||
			(MaxInterferenceSeed > ClosestInterferenceSeedMax + InterferenceSeedEncodingError));

		// Detect interference solely based on the inteference seed, but need to take into account low frequency
		// gradien that there may be in the neighborhood to avoid ghosting on high contrast geometric edges.
		//bIsInterference = bRejectInterferenceSeed;
		bIsInterference = bRejectInterferenceSeedWithGradient;

		Debug.r = bIsInterference ? 1.0 : 0.0;
		Debug.g = InputSeedMax - InputSeedMin;
		Debug.b = ClosestInterferenceSeedMax;
		Debug.a = MaxInterferenceSeed;
		
		Debug.b = ClosestInterferenceSeedMax;
		Debug.a = MinInterferenceSeed;

		//FLATTEN
		//if (bOffScreen)
		//{
		//	bIsInterference = false;
		//}
	}
	#endif

	taa_half3 PrevColor = TransformColorForClampingBox(FilteredPredictionSceneColorTexture[InputPixelPos]);

	taa_half Rejection = 1.0;
	#if 1
	{
		taa_half3 ClampedPrevColor = clamp(PrevColor, InputMinColor, InputMaxColor);

		Rejection = MeasureRejectionFactor(
			PrevColor, ClampedPrevColor,
			InputCenterColor, InputMinColor, InputMaxColor,
			MeasureBackbufferLDRQuantizationErrorFromHDRLuma(max(PrevColor[0], ClampedPrevColor[0])));
		
		//Debug.rgb = abs(YCoCgToRGB(PrevColor - ClampedPrevColor)) / max3(YCoCgToRGB(InputMaxColor), YCoCgToRGB(InputCenterColor), 0.01);
	}
	#endif
	
	#if DIM_MOIRE_HEURISTIC
	{
		if (bIsInterference)
		{
			InterferenceWeight = 0.0;
		}
		 
		Rejection = saturate(Rejection + 1.0 - InterferenceWeight);
		
		Debug.r = InterferenceWeight;
	}
	#endif

	if (ParallaxRejectionMask < taa_half(PARALLAX_REJECTION_MASK_THRESHOLD))
	{
		Rejection = taa_half(1.0);
	}

	#if CONFIG_OUTPUT_HALF_RES
	{
		SharedRejection[GroupThreadIndex] = Rejection;

		GroupMemoryBarrierWithGroupSync();

		UNROLL
		for (uint i = 1; i < 4; i++)
		{
			uint ButterflySwap = i;

			Rejection = min(Rejection, SharedRejection[GroupThreadIndex ^ ButterflySwap]);
		}

		bool bIsValid = all(InputPixelPos <= taa_short2(InputPixelPosMax)) && all((taa_ushort2(InputPixelPos - taa_short2(InputPixelPosMin)) % taa_ushort(2)) == taa_ushort(0));

		taa_ushort2 OutputPixelPos = taa_ushort2(InputPixelPos - taa_short2(InputPixelPosMin)) / taa_ushort(2);
		OutputPixelPos.x = bIsValid ? OutputPixelPos.x : ~taa_ushort(0);

		HistoryRejectionOutput[OutputPixelPos] = Rejection;
	}
	#else
	{
		bool bIsValid = all(InputPixelPos <= taa_short2(InputPixelPosMax));

		taa_ushort2 OutputPixelPos = taa_ushort2(InputPixelPos - taa_short2(InputPixelPosMin));
		OutputPixelPos.x = bIsValid ? OutputPixelPos.x : ~taa_ushort(0);

		HistoryRejectionOutput[OutputPixelPos] = Rejection;
	}
	#endif

	#if DEBUG_OUTPUT
	{
		taa_short2 OutputPixelPos = InvalidateOutputPixelPos(taa_ushort2(InputPixelPos), InputPixelPosMax);
		DebugOutput[OutputPixelPos] = Debug;
	}
	#endif
}
