// Copyright Epic Games, Inc. All Rights Reserved.

#include "TSRCommon.ush"


//------------------------------------------------------- CONFIG

#define TILE_SIZE 8

#define CONFIG_KERNEL 0

#define CONFIG_OUTPUT_HALF_RES (DIM_OUTPUT_HALF_RES)


//------------------------------------------------------- PARAMETERS

float4x4 RotationalClipToPrevClip;
float3 OutputQuantizationError;

Texture2D<taa_half3> InputSceneColorTexture;
Texture2D<float2> DilatedVelocityTexture;
Texture2D<float> ClosestDepthTexture;
Texture2D<uint> PrevUseCountTexture;
Texture2D<uint> PrevClosestDepthTexture;
Texture2D<uint> ParallaxFactorTexture;

Texture2D<taa_half3> PrevHistory_LowFrequency;
Texture2D<taa_half3> PrevHistory_HighFrequency;
Texture2D<taa_half2> PrevHistory_Metadata;
Texture2D<taa_half4> PrevHistory_Translucency;
Texture2D<taa_subpixel_details> PrevHistory_SubpixelDetails;

Texture2D<half> PrevHistory_LowResTextures_0;
Texture2D<uint> PrevHistory_SuperResTextures_0;

RWTexture2D<taa_half3> HalfResSceneColorOutput;
RWTexture2D<taa_half3> HalfResPredictionSceneColorOutput;
RWTexture2D<taa_half> HalfResParallaxRejectionMaskOutput;

RWTexture2D<taa_half3> PredictionSceneColorOutput;
RWTexture2D<taa_half> ParallaxRejectionMaskOutput;
RWTexture2D<taa_half4> InterferenceSeedOutput;


//------------------------------------------------------- LDS

groupshared taa_half3 SharedInputColor[TILE_SIZE * TILE_SIZE];
groupshared taa_half4 SharedHistoryColorAndMask[TILE_SIZE * TILE_SIZE];


//------------------------------------------------------- ENTRY POINT

taa_half3 TransformToComparisonColorSpace(taa_half3 Color)
{
	return Color;
	//return log2(Color);
	//return Color *HdrWeight4(Color); // *float3(HdrWeightY(Color.r), HdrWeightY(Color.g), HdrWeightY(Color.b));
}


//------------------------------------------------------- ENTRY POINT

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void MainCS(
	uint2 GroupId : SV_GroupID,
	uint GroupThreadIndex : SV_GroupIndex)
{
	float4 Debug = 0;
	
	uint2 DispatchThreadId = (
		ZOrder2D(GroupThreadIndex, log2(TILE_SIZE)) +
		GroupId * uint2(TILE_SIZE, TILE_SIZE));

	uint2 InputPixelPos = InputInfo_ViewportMin + DispatchThreadId;
	
	float2 ViewportUV = (float2(DispatchThreadId) + 0.5f) * InputInfo_ViewportSizeInverse;
	float2 ScreenPos = ViewportUVToScreenPos(ViewportUV);
	float2 InputBufferUV = (InputPixelPos + 0.5) * InputInfo_ExtentInverse;
	
	float2 EncodedVelocity = DilatedVelocityTexture[InputPixelPos];
	float DeviceZ = ClosestDepthTexture[InputPixelPos];
	taa_half ParallaxFactor = UncompressParallaxFactor((ParallaxFactorTexture[InputPixelPos] >> 4) & 0xF);
	taa_half3 InputSceneColor = InputSceneColorTexture[InputPixelPos];
	
	taa_half ClosestInputLuma4 = Luma4(InputSceneColor);
	taa_half InputInterferenceSeed = LumaToInterferenceSeed(ClosestInputLuma4);

	float WorldDepth = ConvertFromDeviceZ(DeviceZ);
	
	// Compute the parralax rejection mask
	taa_half ParallaxRejectionMask = 0.0;
	{
		float2 PrevScreenPos = ScreenPos - DecodeVelocityFromTexture(float4(EncodedVelocity, 0.0, 0.0)).xy;
		float2 PrevInputBufferUV = (InputInfo_ScreenPosToViewportScale * PrevScreenPos + InputInfo_ScreenPosToViewportBias) * InputInfo_ExtentInverse;
		
		FBilinearSampleInfos BilinearInter = GetBilinearSampleLevelInfos(PrevInputBufferUV, InputInfo_Extent, InputInfo_ExtentInverse);

		UNROLL_N(4)
		for (uint i = 0; i < 4; i++)
		{
			float BilinearWeight = GetSampleWeight(BilinearInter, i);
			uint2 PixelPos = GetSamplePixelCoord(BilinearInter, i);

			bool bValidPixelPos = all(PixelPos >= InputInfo_ViewportMin && PixelPos < InputInfo_ViewportMax);

			#if COMPRESS_PREV_USE_COUNT
				uint2 CompressedUseCountPixelPos;
				uint Shift;
				ComputeCompressedUseCountPixelCoordinates(PixelPos, /* out */ CompressedUseCountPixelPos, /* out */ Shift);

				uint HistoryUseCount = (PrevUseCountTexture[CompressedUseCountPixelPos] >> (8 * Shift)) & 0xFF;
			#else
				uint HistoryUseCount = PrevUseCountTexture[PixelPos];
			#endif

			float HistoryClosestDeviceZ = f16tof32(PrevClosestDepthTexture[PixelPos]);
			float HistoryClosestWorldDepth = ConvertFromDeviceZ(HistoryClosestDeviceZ);

			taa_half DepthRejection;
			{
				const float WorldDepthToPixelWorldRadius = GetTanHalfFieldOfView().x * InputInfo_ExtentInverse.x;
				const float PixelDepthError = 3.0;
				const float RadiusToDiamater = 2.0;
			
				float WorldDepthEpsilon = (WorldDepthToPixelWorldRadius * RadiusToDiamater * PixelDepthError) * HistoryClosestWorldDepth; 
				float DeltaDepth = abs(HistoryClosestWorldDepth - WorldDepth);

				DepthRejection = saturate(taa_half(2.0) - taa_half(DeltaDepth / WorldDepthEpsilon));
			}

			taa_half HistoryGhostingRejection = saturate(taa_half(1.0) - taa_half(3.0) * abs(taa_half(HistoryUseCount) * rcp(taa_half(PREV_USE_COUNT_QUANTIZATION)) - taa_half(1.0)));

			FLATTEN
			if (bValidPixelPos)
				ParallaxRejectionMask += taa_half(BilinearWeight) * max(DepthRejection, HistoryGhostingRejection);
		}
	}

	// Pixel coordinate of the input pixel in the predictor viewport.
	float2 InputPPCk = float2(InputPixelPos - InputInfo_ViewportMin) + 0.5f - InputJitter;
	float2 OutputViewportUV = InputPPCk * InputInfo_ViewportSizeInverse;
	float2 OutputScreenPos = ViewportUVToScreenPos(OutputViewportUV);

	float2 PrevOutputScreenPos = OutputScreenPos - DecodeVelocityFromTexture(float4(EncodedVelocity, 0.0, 0.0)).xy;

	float2 PrevOutputViewportUV = ScreenPosToViewportUV(PrevOutputScreenPos);

	float2 HistoryPPCk = PrevOutputViewportUV * PrevHistoryInfo_ViewportSize;

	// Pixel coordinate of the center of the nearest predictor pixel O.
	float2 HistoryPPCo = floor(HistoryPPCk) + 0.5;
	float2 HistoryBufferUV = HistoryPPCo * PrevHistoryInfo_ExtentInverse;

	// Vector in pixel between pixel K -> O.
	taa_half2 dKO = taa_half2(HistoryPPCo - HistoryPPCk);
	
	// Sample the history
	taa_half3 DecimatedColor;
	taa_half HistoryMaxRejectionFactor;

	taa_half ClosestInterferenceSeed;
	taa_half IntegratedInterferenceSeed;
	taa_half MinInterferenceSeed;
	taa_half MaxInterferenceSeed;
	{
		float2 KernelHistoryBufferUV = clamp(
			HistoryPPCk * PrevHistoryInfo_ExtentInverse,
			PrevHistoryInfo_UVViewportBilinearMin,
			PrevHistoryInfo_UVViewportBilinearMax);
		
		float2 PrevInputBufferUV = (InputInfo_ScreenPosToViewportScale * PrevOutputScreenPos + InputInfo_ScreenPosToViewportBias) * InputInfo_ExtentInverse;

		#if DIM_MOIRE_HEURISTIC
		{
			const uint KernelSize = 4;

			uint SuperResPayloads[16];

			uint ClosestPayload = ~0;
			uint ClosestAge = 0;
			taa_half ClosestDistanceToSeed = 0.2;

			Debug.r = InputInterferenceSeed;

			// Sample the super res history and find an aproximative age of the input pixel.
			UNROLL
			for (uint y = 0; y < KernelSize; y++)
			{
				UNROLL
				for (uint x = 0; x < KernelSize; x++)
				{
					const float2 Offset = float2(x, y) - (KernelSize - 1.0) * 0.5;
					
					float2 SampleHistoryBufferUV = clamp(
						(HistoryPPCk * 2.0 + Offset) * PrevHistoryInfo_ExtentInverse * rcp(float(SUPERRES_RES_MULTIPLIER)),
						PrevHistoryInfo_UVViewportBilinearMin,
						PrevHistoryInfo_UVViewportBilinearMax);

					uint2 SuperResPixelCoord = uint2(SampleHistoryBufferUV * PrevHistoryInfo_Extent * float(SUPERRES_RES_MULTIPLIER));

					uint SubpixelPayload = PrevHistory_SuperResTextures_0[SuperResPixelCoord];
					FSuperResHistory UnpackedSubpixel = UnpackSuperResHistory(SubpixelPayload);

					SuperResPayloads[y * 4 + x] = SubpixelPayload;

					taa_half DistanceToSeed = abs(InputInterferenceSeed - UnpackedSubpixel.InterferenceSeed);

					// UnpackedSubpixel.Age >= ClosestAge && 

					FLATTEN
					if (DistanceToSeed < ClosestDistanceToSeed)
					{
						ClosestPayload = SubpixelPayload;
						ClosestAge = UnpackedSubpixel.Age;
						ClosestDistanceToSeed = DistanceToSeed;
					}
				}
			}
			
			uint AgeMin = UnpackSuperResHistory(ClosestPayload).Age;
			uint AgeMax = UnpackSuperResHistory(ClosestPayload).Age + 4;

			ClosestInterferenceSeed = UnpackSuperResHistory(ClosestPayload).InterferenceSeed;

			MinInterferenceSeed = 1.0;
			MaxInterferenceSeed = 0.0;

			// Find out if there is high frequency details in the history with that age.
			UNROLL
			for (uint i = 0; i < KernelSize * KernelSize; i++)
			{
				FSuperResHistory UnpackedSubpixel = UnpackSuperResHistory(SuperResPayloads[i]);

				bool bAgeBilateralWeight = UnpackedSubpixel.Age >= AgeMin && UnpackedSubpixel.Age <= AgeMax;

				FLATTEN
				if (bAgeBilateralWeight && ClosestPayload != ~0)
				{
					MinInterferenceSeed = min(MinInterferenceSeed, UnpackedSubpixel.InterferenceSeed);
					MaxInterferenceSeed = max(MaxInterferenceSeed, UnpackedSubpixel.InterferenceSeed);
				}

			}
			
			// actually integrating SubpixelSeed stil suffer interference that causes instability. So instead take
			// average of min and max that turns out interference free.
			IntegratedInterferenceSeed = (MinInterferenceSeed + MaxInterferenceSeed) * 0.5;
		}
		#endif // DIM_MOIRE_HEURISTIC

		taa_half PrevUninterferenceSeed = PrevHistory_LowResTextures_0.SampleLevel(GlobalBilinearClampedSampler, PrevInputBufferUV, 0);
		taa_half PrevUninterferenceLuma = PrevUninterferenceSeed * HdrWeightInvY(PrevUninterferenceSeed);

		PrevUninterferenceLuma /= MoireInvExposure;

		#if !DIM_MOIRE_HEURISTIC || 2
		{
			DecimatedColor = PrevHistory_LowFrequency.SampleLevel(GlobalBilinearClampedSampler, KernelHistoryBufferUV, 0);
			
			// Cancels out the flickering Luma component with the interference free luma from the inteference seed of the history.
			#if DIM_MOIRE_HEURISTIC && 1
			{
				DecimatedColor *= PrevUninterferenceLuma * SafeRcp(Luma4(DecimatedColor));
			}
			#endif
		}
		#else
		{
			DecimatedColor = 0.0;
			UNROLL_N(4)
			for (uint i = 0; i < 4; i++)
			{
				const float2 PixelOffset = float2(Offsets2x2[i]) - 0.5;

				float2 SampleBufferUV = KernelHistoryBufferUV + PixelOffset * PrevHistoryInfo_ExtentInverse; 
				SampleBufferUV = clamp(
					SampleBufferUV,
					PrevHistoryInfo_UVViewportBilinearMin,
					PrevHistoryInfo_UVViewportBilinearMax);
				
				taa_half3 HistorySample = PrevHistory_LowFrequency.SampleLevel(GlobalBilinearClampedSampler, SampleBufferUV, 0);

				// Cancels out the flickering Luma component with the interference free luma from the inteference seed of the history.
				#if DIM_MOIRE_HEURISTIC
				{
					HistorySample *= PrevUninterferenceLuma * SafeRcp(Luma4(HistorySample));
				}
				#endif

				DecimatedColor += HistorySample;
			}

			DecimatedColor *= rcp(4.0);
		}
		#endif

		// Compute the parallax rejection factor of the details in the history.
		FSubpixelNeighborhood SubpixelNeigborhood = GatherPrevSubpixelNeighborhood(PrevHistory_SubpixelDetails, KernelHistoryBufferUV);
		{
			uint EncodedHistoryMaxRejectionFactor = 0;

			UNROLL_N(SUB_PIXEL_COUNT)
			for (uint SubpixelId = 0; SubpixelId < SUB_PIXEL_COUNT; SubpixelId++)
			{
				taa_subpixel_payload SubpixelPayload = GetSubpixelPayload(SubpixelNeigborhood, SubpixelId);
				taa_subpixel_payload EncodedRejectionFactor = (SubpixelPayload >> SUB_PIXEL_PARALLAX_FACTOR_BIT_OFFSET) & SUB_PIXEL_PARALLAX_FACTOR_BIT_MASK;

				EncodedHistoryMaxRejectionFactor = max(EncodedHistoryMaxRejectionFactor, EncodedRejectionFactor);
			}

			HistoryMaxRejectionFactor = UncompressParallaxFactor(EncodedHistoryMaxRejectionFactor);
		}
	}
	
	// Reject subpixel details that might be in history but not input just based on their parrallax
	{
		taa_half HistorySubdetailRejectionFactor = max(HistoryMaxRejectionFactor / ParallaxFactor, taa_half(1.0));

		float4 ThisClip = float4(ScreenPos, DeviceZ, 1);
		float4 PrevClip = mul(ThisClip, View.ClipToPrevClip);
		float2 PrevScreen = PrevClip.xy / PrevClip.w;
			
		float4 RotationalPrevClip = mul(ThisClip, RotationalClipToPrevClip);
		float2 RotationalPrevScreen = RotationalPrevClip.xy / RotationalPrevClip.w;
			
		taa_half PixelParallaxVelocity = taa_half(0.5) * length(taa_half2(RotationalPrevScreen - PrevScreen) * InputInfo_Extent);
		taa_half HistorySubdetailAdditionalParralax = (HistorySubdetailRejectionFactor - taa_half(1.0)) * PixelParallaxVelocity;

		taa_half HistoryParallaxRejectionMask = saturate(taa_half(1.0) - HistorySubdetailAdditionalParralax);

		ParallaxRejectionMask = min(ParallaxRejectionMask, HistoryParallaxRejectionMask);
	}

	// Immediately reject based on the rejection mask
	FLATTEN
	if ((PrevOutputScreenPos.x < -1.0) ||
		(PrevOutputScreenPos.y < -1.0) ||
		(PrevOutputScreenPos.x > 1.0) ||
		(PrevOutputScreenPos.y > 1.0))
	//if (IsOffScreen2(bCameraCut, PrevOutputScreenPos, /* ParallaxRejectionMask = */ 1.0))
	{
		ParallaxRejectionMask = taa_half(0.0);
	}

	
	#if CONFIG_OUTPUT_HALF_RES
	{
		SharedInputColor[GroupThreadIndex] = InputSceneColor;
		SharedHistoryColorAndMask[GroupThreadIndex] = taa_half4(DecimatedColor, ParallaxRejectionMask);

		GroupMemoryBarrierWithGroupSync();

		bool bCheckerboard = (((InputPixelPos.x ^ InputPixelPos.y) >> 1) & 0x1) != 0;

		half3 HalfResInputSceneColor = InputSceneColor;
		half3 HalfResDecimatedColor = DecimatedColor;
		half HalfResParallaxRejectionMask = ParallaxRejectionMask;

		UNROLL
		for (uint i = 1; i < 4; i++)
		{
			uint ButterflySwap = i;
			
			if (bCheckerboard)
			{
				HalfResInputSceneColor = min(HalfResInputSceneColor, SharedInputColor[GroupThreadIndex ^ ButterflySwap]);
			}
			else
			{
				HalfResInputSceneColor = max(HalfResInputSceneColor, SharedInputColor[GroupThreadIndex ^ ButterflySwap]);
			}
			HalfResDecimatedColor += SharedHistoryColorAndMask[GroupThreadIndex ^ ButterflySwap].rgb;

			HalfResParallaxRejectionMask += SharedHistoryColorAndMask[GroupThreadIndex ^ ButterflySwap].a;
		}

		HalfResDecimatedColor *= 0.25;
		HalfResParallaxRejectionMask *= 0.25;

		#if CONFIG_ENABLE_STOCASTIC_QUANTIZATION
		{
			uint2 Random = Rand3DPCG16(int3((InputPixelPos - InputInfo_ViewportMin) / 2, View.StateFrameIndexMod8)).xy;
			float2 E = Hammersley16(0, 1, Random);

			HalfResInputSceneColor = QuantizeForFloatRenderTarget(HalfResInputSceneColor, E.x, OutputQuantizationError);
			HalfResDecimatedColor = QuantizeForFloatRenderTarget(HalfResDecimatedColor, E.x, OutputQuantizationError);
		}
		#endif

		if (all(InputPixelPos < InputInfo_ViewportMax) && all(((InputPixelPos - InputInfo_ViewportMin) % 2) == 0))
		{
			HalfResSceneColorOutput[InputPixelPos / 2] = HalfResInputSceneColor;
			HalfResPredictionSceneColorOutput[InputPixelPos / 2] = HalfResDecimatedColor;
			HalfResParallaxRejectionMaskOutput[InputPixelPos / 2] = HalfResParallaxRejectionMask;
		}
	}
	#endif

	#if CONFIG_ENABLE_STOCASTIC_QUANTIZATION
	{
		uint2 Random = Rand3DPCG16(int3(InputPixelPos - InputInfo_ViewportMin, View.StateFrameIndexMod8)).xy;
		float2 E = Hammersley16(0, 1, Random);

		DecimatedColor = QuantizeForFloatRenderTarget(DecimatedColor, E.x, OutputQuantizationError);
	}
	#endif

	if (all(InputPixelPos < InputInfo_ViewportMax))
	{
		#if !CONFIG_OUTPUT_HALF_RES
		{
			PredictionSceneColorOutput[InputPixelPos] = DecimatedColor;
		}
		#endif
		
		ParallaxRejectionMaskOutput[InputPixelPos] = ParallaxRejectionMask;

		#if DIM_MOIRE_HEURISTIC
		{
			InterferenceSeedOutput[InputPixelPos] = taa_half4(ClosestInterferenceSeed, IntegratedInterferenceSeed, MinInterferenceSeed, MaxInterferenceSeed);
		}
		#endif

		#if DEBUG_OUTPUT
		{
			DebugOutput[InputPixelPos] = Debug;
		}
		#endif
	}
}
