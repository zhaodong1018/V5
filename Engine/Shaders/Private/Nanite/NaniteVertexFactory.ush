// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../VertexFactoryCommon.ush"
#include "../LightmapData.ush"
#include "NaniteDataDecode.ush"
#include "NaniteAttributeDecode.ush"

// Always enable all inputs to work around shader linkage errors without introducing permutations.
// Make sure this matches definition in ExportGBuffer.usf
struct FVertexFactoryInterpolantsVSToPS
{
//#if NEEDS_LIGHTMAP_COORDINATE
	nointerpolation float4 LightMapCoordinate : TEXCOORD3;
//#endif
//#if VF_USE_PRIMITIVE_SCENE_DATA && NEEDS_LIGHTMAP_COORDINATE
	nointerpolation uint LightmapDataIndex : LIGHTMAP_ID;
//#endif
//#if INSTANCED_STEREO
	nointerpolation uint EyeIndex : PACKED_EYE_INDEX;
//#endif
//#if NANITE_MULTI_VIEW
	nointerpolation uint ViewIndex : PACKED_VIEW_INDEX;
//#endif
};

#if NEEDS_LIGHTMAP_COORDINATE

void GetLightMapCoordinates(FVertexFactoryInterpolantsVSToPS Interpolants, out float2 LightmapUV0, out float2 LightmapUV1, out uint LightmapDataIndex)
{
	LightmapUV0 = Interpolants.LightMapCoordinate.xy * float2(1.0, 0.5);
	LightmapUV1 = LightmapUV0 + float2(0.0, 0.5);

#if VF_USE_PRIMITIVE_SCENE_DATA
	LightmapDataIndex = Interpolants.LightmapDataIndex;
#else
	LightmapDataIndex = 0;
#endif
}

void GetShadowMapCoordinate(FVertexFactoryInterpolantsVSToPS Interpolants, out float2 ShadowMapCoordinate, out uint LightmapDataIndex)
{
#if VF_USE_PRIMITIVE_SCENE_DATA
	LightmapDataIndex = Interpolants.LightmapDataIndex;
#else
	LightmapDataIndex = 0;
#endif
	ShadowMapCoordinate = Interpolants.LightMapCoordinate.zw;
}

void SetLightMapCoordinate(inout FVertexFactoryInterpolantsVSToPS Interpolants, float2 InLightMapCoordinate, float2 InShadowMapCoordinate)
{
	Interpolants.LightMapCoordinate.xy = InLightMapCoordinate;
	Interpolants.LightMapCoordinate.zw = InShadowMapCoordinate;
}

void SetLightMapDataIndex(inout FVertexFactoryInterpolantsVSToPS Interpolants, uint LightmapDataIndex)
{
#if VF_USE_PRIMITIVE_SCENE_DATA
	Interpolants.LightmapDataIndex = LightmapDataIndex;
#endif
}

#endif // NEEDS_LIGHTMAP_COORDINATE

/** Converts from vertex factory specific interpolants to a FMaterialPixelParameters, which is used by material inputs. */
FMaterialPixelParameters GetMaterialPixelParameters(FNaniteView NaniteView, inout FVertexFactoryInterpolantsVSToPS Interpolants, inout float4 SvPosition)
{
	FMaterialPixelParameters Result = (FMaterialPixelParameters)0;

	const uint2 PixelPos = SvPosition.xy - float2(0.5f, 0.5f);
	const UlongType Pixel = Nanite.VisBuffer64[PixelPos];

	uint DepthInt = 0;
	uint VisibleClusterIndex = 0;
	uint TriIndex = 0;
	UnpackVisPixel(Pixel, DepthInt, VisibleClusterIndex, TriIndex);

	if (VisibleClusterIndex != 0xFFFFFFFF)
	{
		FVisibleCluster VisibleCluster           = GetVisibleCluster(VisibleClusterIndex);
		FInstanceSceneData InstanceData          = GetInstanceSceneData(VisibleCluster, false);
		FInstanceDynamicData InstanceDynamicData = CalculateInstanceDynamicData(NaniteView, InstanceData);
		FPrimitiveSceneData PrimitiveData        = GetPrimitiveData(InstanceData.PrimitiveId);
		FCluster Cluster                         = GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);

		const uint3 TriIndices = ReadTriangleIndices(Cluster, TriIndex);

		const float3 PointLocal0 = DecodePosition(TriIndices.x, Cluster);
		const float3 PointLocal1 = DecodePosition(TriIndices.y, Cluster);
		const float3 PointLocal2 = DecodePosition(TriIndices.z, Cluster);

		const float4 PointClip0 = mul(float4(PointLocal0, 1), InstanceDynamicData.LocalToClip);
		const float4 PointClip1 = mul(float4(PointLocal1, 1), InstanceDynamicData.LocalToClip);
		const float4 PointClip2 = mul(float4(PointLocal2, 1), InstanceDynamicData.LocalToClip);

		const float2 PixelClip = (SvPosition.xy - NaniteView.ViewRect.xy) * NaniteView.ViewSizeAndInvSize.zw * float2(2, -2) + float2(-1, 1);

		// Calculate perspective correct barycentric coordinates with screen derivatives
		const FBarycentrics Barycentrics = CalculateTriangleBarycentrics(PixelClip, PointClip0, PointClip1, PointClip2, NaniteView.ViewSizeAndInvSize.zw);

		const FNaniteAttributeData AttributeData = GetAttributeData(
			Cluster,
			TriIndices,
			PointLocal0,
			PointLocal1,
			PointLocal2,
			Barycentrics,
			InstanceData,
			NUM_TEX_COORD_INTERPOLATORS
		);

	#if INTERPOLATE_VERTEX_COLOR
		Result.VertexColor = AttributeData.VertexColor;
		Result.VertexColor_DDX = AttributeData.VertexColor_DDX;
		Result.VertexColor_DDY = AttributeData.VertexColor_DDY;
	#else
		// Coerce compiler into DCE as much code as possible.
		Result.VertexColor = float4(1, 1, 1, 1);
		Result.VertexColor_DDX = 0.0f;
		Result.VertexColor_DDY = 0.0f;
	#endif

		Result.TangentToWorld = AttributeData.TangentToWorld;
		Result.UnMirrored = AttributeData.UnMirrored;

	#if NUM_TEX_COORD_INTERPOLATORS > 0
		UNROLL
		for (uint TexCoordIndex = 0; TexCoordIndex < NUM_TEX_COORD_INTERPOLATORS; TexCoordIndex++)
		{
			// Protect against case where Nanite max UV count is lower than what the material may define.
			if (TexCoordIndex < MAX_NANITE_UVS)
			{
				Result.TexCoords[TexCoordIndex] = AttributeData.TexCoords[TexCoordIndex];
				Result.TexCoords_DDX[TexCoordIndex] = AttributeData.TexCoords_DDX[TexCoordIndex];
				Result.TexCoords_DDY[TexCoordIndex] = AttributeData.TexCoords_DDY[TexCoordIndex];
			}
		}
	#endif

		const float3 PointLocal = Barycentrics.UVW.x * PointLocal0 + Barycentrics.UVW.y * PointLocal1 + Barycentrics.UVW.z * PointLocal2;

		Result.PrevScreenPosition = mul( float4(PointLocal, 1), InstanceDynamicData.PrevLocalToClip );
		//Result.PrevScreenPosition = float4( Result.PrevScreenPosition.xyz / Result.PrevScreenPosition.w, 1 );

		const float3 PointWorld0 = mul(float4(PointLocal0, 1), InstanceDynamicData.LocalToTranslatedWorld).xyz;
		const float3 PointWorld1 = mul(float4(PointLocal1, 1), InstanceDynamicData.LocalToTranslatedWorld).xyz;
		const float3 PointWorld2 = mul(float4(PointLocal2, 1), InstanceDynamicData.LocalToTranslatedWorld).xyz;
		const float3 PointWorld = Barycentrics.UVW.x * PointWorld0 + Barycentrics.UVW.y * PointWorld1 + Barycentrics.UVW.z * PointWorld2;
		
		Result.WorldPosition_CamRelative = PointWorld;
		Result.WorldPosition_DDX = Barycentrics.UVW_dx.x * PointWorld0 + Barycentrics.UVW_dx.y * PointWorld1 + Barycentrics.UVW_dx.z * PointWorld2;
		Result.WorldPosition_DDY = Barycentrics.UVW_dy.x * PointWorld0 + Barycentrics.UVW_dy.y * PointWorld1 + Barycentrics.UVW_dy.z * PointWorld2;

		// Update to real depth from VisBuffer
		SvPosition.z = asfloat(DepthInt);

		// Update screen W and all screen derivatives. This is rarely used and will be dead code eliminated most of the time.
		{
			const float2 PointClip0ZW = mul(float4(PointWorld0, 1.0f), NaniteView.TranslatedWorldToClip).zw;
			const float2 PointClip1ZW = mul(float4(PointWorld1, 1.0f), NaniteView.TranslatedWorldToClip).zw;
			const float2 PointClip2ZW = mul(float4(PointWorld2, 1.0f), NaniteView.TranslatedWorldToClip).zw;

			const float2 PointClipZW = Barycentrics.UVW.x * PointClip0ZW + Barycentrics.UVW.y * PointClip1ZW + Barycentrics.UVW.z * PointClip2ZW;
			SvPosition.w = PointClipZW.y;

			float2 Z_DDX_DDY = float2(	Barycentrics.UVW_dx.x * PointClip0ZW.x + Barycentrics.UVW_dx.y * PointClip1ZW.x + Barycentrics.UVW_dx.z * PointClip2ZW.x,
										Barycentrics.UVW_dy.x * PointClip0ZW.x + Barycentrics.UVW_dy.y * PointClip1ZW.x + Barycentrics.UVW_dy.z * PointClip2ZW.x);
			float2 W_DDX_DDY = float2(	Barycentrics.UVW_dx.x * PointClip0ZW.y + Barycentrics.UVW_dx.y * PointClip1ZW.y + Barycentrics.UVW_dx.z * PointClip2ZW.y,
										Barycentrics.UVW_dy.x * PointClip0ZW.y + Barycentrics.UVW_dy.y * PointClip1ZW.y + Barycentrics.UVW_dy.z * PointClip2ZW.y);

			// PPZ = Z / W
			// PPZ' = (Z'W - ZW')/W^2
			float2 PPZ_DDX_DDY = (Z_DDX_DDY * PointClipZW.y - PointClipZW.x * W_DDX_DDY) / (PointClipZW.y * PointClipZW.y);
			SvPositionToResolvedScreenPositionDeriv(SvPosition, PPZ_DDX_DDY, W_DDX_DDY, Result.ScreenPosition, Result.ScreenPosition_DDX, Result.ScreenPosition_DDY);
		}
		
	#if USE_PARTICLE_SUBUVS && NUM_TEX_COORD_INTERPOLATORS > 0
		// Output TexCoord0 for when previewing materials that use ParticleSubUV.
		Result.Particle.SubUVCoords[0] = Result.TexCoords[0];
		Result.Particle.SubUVCoords[1] = Result.TexCoords[0];
	#endif

		// Required for previewing materials that use ParticleColor
		Result.Particle.Color = half4(1, 1, 1, 1);

	#if USES_PER_INSTANCE_RANDOM
		// X = per-instance random, Y = per-instance fade out amount, Z = hide/show flag, W = dither fade cutoff
		Result.PerInstanceParams = float4(InstanceData.RandomID, 0.0f, 0.0f, 0.0f);
	#endif

	#if NEEDS_LIGHTMAP_COORDINATE
		float2 LightMapCoordinate = 0;
		float2 ShadowMapCoordinate = 0;

		const uint LightMapDataIndex = PrimitiveData.LightmapDataIndex;
		const uint LightMapUVIndex   = PrimitiveData.LightmapUVIndex;

		float2 LightMapCoordinateInput;
		float2 LightMapCoordinateInput_DDX;
		float2 LightMapCoordinateInput_DDY;
		if (LightMapUVIndex < NUM_TEX_COORD_INTERPOLATORS)
		{
			LightMapCoordinateInput = AttributeData.TexCoords[LightMapUVIndex];
			LightMapCoordinateInput_DDX = AttributeData.TexCoords_DDX[LightMapUVIndex];
			LightMapCoordinateInput_DDY = AttributeData.TexCoords_DDY[LightMapUVIndex];
		}
		else
		{
			FTexCoord TexCoord = GetTexCoord(Cluster, TriIndices, Barycentrics, LightMapUVIndex);
			LightMapCoordinateInput = TexCoord.Value;
			LightMapCoordinateInput_DDX = TexCoord.DDX;
			LightMapCoordinateInput_DDY = TexCoord.DDY;
		}

		const float4 LightMapCoordinateScaleBias = GetLightmapData(LightMapDataIndex).LightMapCoordinateScaleBias;
		if (PrimitiveData.NumInstanceSceneDataEntries > 1)
		{
			LightMapCoordinate = LightMapCoordinateInput * LightMapCoordinateScaleBias.xy + InstanceData.LightMapAndShadowMapUVBias.xy;
		}
		else
		{
			LightMapCoordinate = LightMapCoordinateInput * LightMapCoordinateScaleBias.xy + LightMapCoordinateScaleBias.zw;
		}

	#if STATICLIGHTING_TEXTUREMASK
		const float4 ShadowMapCoordinateScaleBias = GetLightmapData(LightMapDataIndex).ShadowMapCoordinateScaleBias;
		if (PrimitiveData.NumInstanceSceneDataEntries > 1)
		{
			ShadowMapCoordinate = LightMapCoordinateInput * ShadowMapCoordinateScaleBias.xy + InstanceData.LightMapAndShadowMapUVBias.zw;
		}
		else
		{
			ShadowMapCoordinate = LightMapCoordinateInput * ShadowMapCoordinateScaleBias.xy + ShadowMapCoordinateScaleBias.zw;
		}
	#endif

	#if LIGHTMAP_UV_ACCESS
		// Store unscaled/unbiased lightmap UVs
		Result.LightmapUVs = LightMapCoordinateInput;
		Result.LightmapUVs_DDX = LightMapCoordinateInput_DDX;
		Result.LightmapUVs_DDY = LightMapCoordinateInput_DDY;
	#endif

		SetLightMapCoordinate(Interpolants, LightMapCoordinate, ShadowMapCoordinate);
		SetLightMapDataIndex(Interpolants, LightMapDataIndex);

	#endif // NEEDS_LIGHTMAP_COORDINATE

		// TODO: Temporary hack!
	#if USES_PER_INSTANCE_CUSTOM_DATA
		Result.CustomDataOffset = InstanceData.CustomDataOffset;
		Result.NumCustomDataFloats = InstanceData.NumCustomDataFloats;
		Result.CustomDataFloat0 = InstanceData.CustomDataFloat0;
	#endif

		Result.TwoSidedSign = 1;
		Result.PrimitiveId = InstanceData.PrimitiveId;
		Result.InstanceId  = InstanceData.RelativeId;
	}

	return Result;
}

FMaterialPixelParameters GetMaterialPixelParameters(inout FVertexFactoryInterpolantsVSToPS Interpolants, inout float4 SvPosition)
{
	const FNaniteView NaniteView = GetNaniteView(0);
	return GetMaterialPixelParameters(NaniteView, Interpolants, SvPosition);
}

struct FVertexFactoryRayTracingInterpolants
{
	FVertexFactoryInterpolantsVSToPS InterpolantsVSToPS;
};

float2 VertexFactoryGetRayTracingTextureCoordinate( FVertexFactoryRayTracingInterpolants Interpolants )
{
	return float2(0,0);
}

FVertexFactoryInterpolantsVSToPS VertexFactoryAssignInterpolants(FVertexFactoryRayTracingInterpolants Input)
{
	return Input.InterpolantsVSToPS;
}

FVertexFactoryRayTracingInterpolants VertexFactoryInterpolate(FVertexFactoryRayTracingInterpolants a, float aInterp, FVertexFactoryRayTracingInterpolants b, float bInterp)
{
	return a;
}
