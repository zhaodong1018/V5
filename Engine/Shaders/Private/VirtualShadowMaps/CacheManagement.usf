// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../SceneData.ush"
#include "ProjectionCommon.ush"
#include "PageOverlap.ush"
#include "../ScreenSpaceDenoise/SSDDefinitions.ush"		// For LIGHT_TYPE's

//#include "NaniteDataDecode.ush"
 #include "../Nanite/HZBCull.ush"

#if ENABLE_DEBUG_MODE
#include "../ShaderDrawDebug.ush"
#include "../ColorMap.ush"
#endif

struct FInstanceSceneDataRange
{
	int InstanceSceneDataOffset;
	int NumInstanceSceneDataEntries;
};
StructuredBuffer<FInstanceSceneDataRange> InstanceSceneRanges;
uint NumRemovedItems;

RWStructuredBuffer<uint> OutDynamicCasterFlags;
uint InstanceSceneDataSOAStride;

#if ENABLE_DEBUG_MODE
uint bDrawBounds;
#endif

#if INPUT_KIND == INPUT_KIND_GPU_INSTANCES
StructuredBuffer<uint> InvalidatingInstances;
uint NumInvalidatingInstanceSlots;
#endif

/**
 * Each thread loops over a range on instances loaded from a buffer. The instance bounds are projected to all cached virtual shadow map address space 
 * and any overlapped pages are marked as invalid.
 */
[numthreads(CS_1D_GROUP_SIZE_X, 1, 1)]
void VirtualSmInvalidateInstancePagesCS(
	uint DispatchIndex : SV_DispatchThreadID,
	uint GroupId : SV_GroupID,
	uint GroupThreadIndex : SV_GroupIndex)
{
#if INPUT_KIND == INPUT_KIND_LARGE_RANGES
	// Large instance count ranges use one group per range instead, and use a group-stride loop
	FInstanceSceneDataRange InstanceSceneDataRange = InstanceSceneRanges[GroupId];
	for (int InstanceId = InstanceSceneDataRange.InstanceSceneDataOffset + GroupThreadIndex; InstanceId < InstanceSceneDataRange.NumInstanceSceneDataEntries + InstanceSceneDataRange.InstanceSceneDataOffset; InstanceId += CS_1D_GROUP_SIZE_X)
#elif INPUT_KIND == INPUT_KIND_SMALL_RANGES
	if (DispatchIndex >= NumRemovedItems)
	{
		return;
	}
	FInstanceSceneDataRange InstanceSceneDataRange = InstanceSceneRanges[DispatchIndex];
	for (int InstanceId = InstanceSceneDataRange.InstanceSceneDataOffset; InstanceId < InstanceSceneDataRange.NumInstanceSceneDataEntries + InstanceSceneDataRange.InstanceSceneDataOffset; ++InstanceId)
#else // INPUT_KIND == INPUT_KIND_GPU_INSTANCES
	// The 0th index stores the total number appended
	if (DispatchIndex >= InvalidatingInstances[0])
	{
		return;
	}
	int InstanceId = InvalidatingInstances[1 + DispatchIndex];
#endif
	{
		FInstanceSceneData InstanceSceneData = GetInstanceSceneData(InstanceId, InstanceSceneDataSOAStride);

		// TODO: Clean up hardcoded flag field test.
		bool bCastShadows = InstanceSceneData.ValidInstance 
			&& (GetPrimitiveData(InstanceSceneData.PrimitiveId).Flags & 1U) != 0U;
#if ENABLE_DEBUG_MODE
		uint PageInvalidationCount = 0U;
#endif

		// TODO: test the flag on the instance instead once it is updated correctly InstanceSceneData.CastShadows
		if (bCastShadows)
		{
			for (uint ShadowMapDataIndex = 0; ShadowMapDataIndex < VirtualShadowMap.NumShadowMaps; ++ShadowMapDataIndex)
			{
				// 1. Load cached projection data
				FVirtualShadowMapProjectionShaderData ProjectionData = GetVirtualShadowMapProjectionData(ShadowMapDataIndex);
				const bool bDirectionalLight = (ProjectionData.LightType == LIGHT_TYPE_DIRECTIONAL);

				float4x4 LocalToTranslatedWorld = LWCHackToFloat(InstanceSceneData.LocalToWorld);
				LocalToTranslatedWorld[3].xyz += ProjectionData.ShadowPreViewTranslation;

				// Go back to clip space
				float4x4 UVToClip;
				UVToClip[0] = float4(2, 0, 0, 0);
				UVToClip[1] = float4(0, -2, 0, 0);
				UVToClip[2] = float4(0, 0, 1, 0);
				UVToClip[3] = float4(-1, 1, 0, 1);

				float4x4 LocalToClip = mul(LocalToTranslatedWorld, mul(ProjectionData.TranslatedWorldToShadowUVMatrix, UVToClip));

				FFrustumCullData Cull = BoxCullFrustum(InstanceSceneData.LocalBoundsCenter, InstanceSceneData.LocalBoundsExtent, LocalToClip, !bDirectionalLight, false);

				if (Cull.bIsVisible)
				{
					// 2. figure out overlap and all that
					// case #1 mip-map VSM - loop all mip levels, case #2 clipmap, just one 'mip level'
					int NumMipLevels = (ProjectionData.ClipmapLevelCount <= 0) ? VSM_MAX_MIP_LEVELS : 1;
					{
						for (int MipLevel = 0; MipLevel < NumMipLevels; ++MipLevel)
						{
							int ViewDim = int(uint(VSM_VIRTUAL_MAX_RESOLUTION_XY) >> MipLevel);
							FScreenRect Rect = GetScreenRect(int4(0, 0, ViewDim, ViewDim), Cull, 4);
							// Use Hierarchical mip test to speed up (allows skipping invalidating areas that don't have any flags anyway)
							if (OverlapsAnyValidPage(ProjectionData.VirtualShadowMapId, MipLevel, float2(0.0f, 0.0f), Rect, VSM_ALLOCATED_FLAG))
							{
								uint4 RectPages = uint4(Rect.Pixels) >> VSM_LOG2_PAGE_SIZE;

#if USE_HZB_OCCLUSION
								FPageTestScreenRect HZBTestRect = SetupPageHZBRect(Rect);
#endif // USE_HZB_OCCLUSION

								// Clip to actually allocated pages
								// TODO: move this to be done as part of or before the overlap test?
								uint4 AllocatedBounds = PageRectBounds[ProjectionData.VirtualShadowMapId * VSM_MAX_MIP_LEVELS + MipLevel];
								RectPages.xy = max(RectPages.xy, AllocatedBounds.xy);
								RectPages.zw = min(RectPages.zw, AllocatedBounds.zw);
								if (all(RectPages.zw >= RectPages.xy))
								{
									// 3. do invalidation
									uint PageTableLevelOffset = CalcPageTableLevelOffset(ProjectionData.VirtualShadowMapId, MipLevel);
									for (uint y = RectPages.y; y <= RectPages.w; y++)
									{
										for (uint x = RectPages.x; x <= RectPages.z; x++)
										{
											uint PageFlagOffset = PageTableLevelOffset + CalcPageOffsetInLevel(MipLevel, uint2(x, y));
											uint PageFlag = PageFlags[PageFlagOffset];

											if (PageFlag != 0)
											{
#if USE_HZB_OCCLUSION
												if (!IsPageVisibleHZB(uint2(x, y), PageFlagOffset, HZBTestRect))
												{
													continue;
												}
#endif // USE_HZB_OCCLUSION
												OutDynamicCasterFlags[PageFlagOffset] = 1;
#if ENABLE_DEBUG_MODE
												++PageInvalidationCount;
#endif

											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
#if ENABLE_DEBUG_MODE
		if (bDrawBounds && PageInvalidationCount > 0U)
		{
			float3 Color = float3(0.3f, 0.3f, 0.3f) + ColorMapTurbo(min(1.0f, float(PageInvalidationCount) / 100.0f)) * 0.7f;
			AddOBB(InstanceSceneData.LocalBoundsCenter - InstanceSceneData.LocalBoundsExtent, InstanceSceneData.LocalBoundsCenter + InstanceSceneData.LocalBoundsExtent, float4(Color, 1.0f), LWCHackToFloat(InstanceSceneData.LocalToWorld));
		}
#endif
	}
}
