// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"
#include "../Nanite/HZBCull.ush"
#include "PageAccessCommon.ush"

StructuredBuffer<uint> PageFlags;
StructuredBuffer<uint> HPageFlags;
StructuredBuffer<uint> ShadowHZBPageTable;
// Rectangles bounding allocated pages for each mip level
StructuredBuffer<uint4> PageRectBounds;


// Note: the pixel 'screen' rect in FScreenRect is calculated using only the viewport _size_ as HZB uses a zero-offset buffer.
// However, the page table is with respect to the entire virtual SM so we need to offset here.
// All flags in FlagMask must be set on at least one overlapped page for this to return true
bool OverlapsAnyValidPage( 
	uint ShadowMapID, 
	uint MipLevel, 
	int2 ViewPortRectMin, 
	FScreenRect Rect,
	uint FlagMask = VSM_ALLOCATED_FLAG)
{
	uint4 RectPages = uint4( Rect.Pixels + ViewPortRectMin.xyxy ) >> VSM_LOG2_PAGE_SIZE;

	uint HMipLevel = MipLevelForRect( RectPages, 2 );

	uint PageTableLevelOffset = CalcPageTableLevelOffset( ShadowMapID, MipLevel );

	// Check the page flags directly as not needing h-page flag mip
	if (HMipLevel == 0)
	{
		for( uint y = RectPages.y; y <= RectPages.w; y++ )
		{
			for( uint x = RectPages.x; x <= RectPages.z; x++ )
			{
				if ((PageFlags[PageTableLevelOffset + CalcPageOffsetInLevel(MipLevel, uint2(x, y))] & FlagMask) == FlagMask)
				{
					return true;
				}
			}
		}
	}
	else
	{
		RectPages >>= HMipLevel;

		// Root level size in pages
		uint HLevelSizePages = uint(VSM_LEVEL0_DIM_PAGES_XY) >> (MipLevel + HMipLevel);

		int HPageLevelOffset = ShadowMapID * VirtualShadowMap.HPageTableSize + CalcHPageFlagLevelOffsets(MipLevel)
			+ CalcLevelOffsets( HMipLevel + MipLevel)
			- CalcLevelOffsets( MipLevel + 1U );

		for( uint y = RectPages.y; y <= RectPages.w; y++ )
		{
			for( uint x = RectPages.x; x <= RectPages.z; x++ )
			{
				int HPageFlagOffset = HPageLevelOffset + y * HLevelSizePages + x;
				if( (HPageFlags[ HPageFlagOffset ] & FlagMask) == FlagMask )
				{
					return true;
				}
			}
		}
	}
	return false;
}

static const uint HZB_PAGE_SIZE = VSM_PAGE_SIZE / 2;

bool IsVisibleHZB( uint ShadowMapID, uint MipLevel, FScreenRect Rect )
{
	// Don't have an HZB to test.
	if( ShadowMapID == ~0u )
		return true;

	// Can't go past mip level of 4x4 for a 4x4 test without possibly covering more than 4 pages.
	if( Rect.HZBLevel > VSM_LOG2_PAGE_SIZE - 3 )
	{
#if 1
		return true;
#else
		Rect.HZBLevel = VSM_LOG2_PAGE_SIZE - 3;
		Rect.HZBTexels = int4( Rect.Pixels.xy, max( Rect.Pixels.xy, Rect.Pixels.zw ) );	
		Rect.HZBTexels >>= Rect.HZBLevel + 1;
#endif
	}

	uint PageTableLevelOffset = CalcPageTableLevelOffset( ShadowMapID, MipLevel );

	uint4 RectPages = uint4( Rect.Pixels ) >> VSM_LOG2_PAGE_SIZE;

	for( uint y = RectPages.y; y <= RectPages.w; y++ )
	{
		for( uint x = RectPages.x; x <= RectPages.z; x++ )
		{
			uint2 vPage = uint2(x,y);
			uint PageOffset = PageTableLevelOffset + CalcPageOffsetInLevel( MipLevel, vPage );
			FShadowPhysicalPage pPage = ShadowDecodePageTable( ShadowHZBPageTable[ PageOffset ] );

			if( !pPage.bThisLODValid )
			{
				// If this is a new page we can't consider everything occluded the first time.
				//if( PageFlags[ PageOffset ] != 0 )
				return true;

				// If the receiver points were projected into prev HZB space we could accurately ignore parts of the HZB that weren't relevent.
			}
			else
			{
				uint Shift = VSM_LOG2_PAGE_SIZE - 1 - Rect.HZBLevel;

				FScreenRect ClippedRect = Rect;
				ClippedRect.HZBTexels -= ( vPage << Shift ).xyxy;
				ClippedRect.HZBTexels = clamp( ClippedRect.HZBTexels, 0, (int)HZB_PAGE_SIZE - 1 );
				ClippedRect.HZBTexels += ( pPage.PhysicalAddress << Shift ).xyxy;

				if( IsVisibleHZB( ClippedRect, true ) )
					return true;
			}
		}
	}

	return false;
}

/**
 * Wrapper type to make misuse slightly harder.
 */
struct FPageTestScreenRect
{
	FScreenRect ScreenRect;
	uint HZBLevelPageSizeShift;
	int HZBLevelPageSizeInclusive;
};


/**
 * Set up a screen rect and pre-computed data for testing pages against HZB, this assumes a 4x4-HZB FScreenRect
 * as input. The resulting rect has been clamped to the mip level where a page is 4x4 texels, as higher mips are meaningless.
 */
FPageTestScreenRect SetupPageHZBRect(FScreenRect ScreenRect)
{
	FPageTestScreenRect Result;
	Result.ScreenRect = ScreenRect;
	// Clamp to level where a page is 4x4 (HZB mip 0 is half-size)
	if (Result.ScreenRect.HZBLevel > VSM_LOG2_PAGE_SIZE - 3U)
	{
		// Adjust HZB texel rect to match new mip level, this will be too large, but is clipped below.
		Result.ScreenRect.HZBTexels = int4(Result.ScreenRect.Pixels.xy, max(Result.ScreenRect.Pixels.xy, Result.ScreenRect.Pixels.zw)) >> (VSM_LOG2_PAGE_SIZE - 2U);
		Result.ScreenRect.HZBLevel = VSM_LOG2_PAGE_SIZE - 3U;
	}
	Result.HZBLevelPageSizeShift = VSM_LOG2_PAGE_SIZE - 1U - Result.ScreenRect.HZBLevel;
	Result.HZBLevelPageSizeInclusive = (1 << Result.HZBLevelPageSizeShift) - 1;
	return Result;
}


bool IsPageVisibleHZB(uint2 vPage, uint PageFlagOffset, FPageTestScreenRect PageTestScreenRect)
{
	FShadowPhysicalPage pPage = ShadowDecodePageTable(ShadowHZBPageTable[PageFlagOffset]);

	if (pPage.bThisLODValid)
	{
		FScreenRect HZBTestRect = PageTestScreenRect.ScreenRect;

		// Move to page local (in mip level) space and clamp rect to page size.
		HZBTestRect.HZBTexels -= (vPage << PageTestScreenRect.HZBLevelPageSizeShift).xyxy;
		HZBTestRect.HZBTexels = clamp(HZBTestRect.HZBTexels, 0, PageTestScreenRect.HZBLevelPageSizeInclusive);
		// Translate to physical address space
		HZBTestRect.HZBTexels += (pPage.PhysicalAddress << PageTestScreenRect.HZBLevelPageSizeShift).xyxy;

		// Skip invalidation if the instance is occluded
		return IsVisibleHZB(HZBTestRect, true);
	}

	return true;
}