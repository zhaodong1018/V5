// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	PageManagement.usf: 
=============================================================================*/

#include "../HairStrands/HairStrandsVisibilityCommonStruct.ush"
#include "../Common.ush"
#include "../WaveOpUtil.ush"
#include "../LightGridCommon.ush"
#include "../SceneTexturesCommon.ush"
#include "../DeferredShadingCommon.ush"
#include "../MortonCode.ush"
#include "../Nanite/NaniteDataDecode.ush"
#include "../HairStrands/HairStrandsVisibilityCommon.ush"
#include "../HairStrands/HairStrandsTileCommon.ush"
#include "PageAccessCommon.ush"
#include "PageCacheCommon.ush"
#include "PageOverlap.ush"
#include "ProjectionCommon.ush"
#include "ProjectionSpot.ush"
#include "ProjectionDirectional.ush"

#ifndef VSM_GENERATE_STATS
#define VSM_GENERATE_STATS 0
#endif // VSM_GENERATE_STATS

#if VSM_GENERATE_STATS
RWStructuredBuffer<uint> OutStatsBuffer;
#endif // VSM_GENERATE_STATS

void StatsBufferWrite(uint Index, uint Value)
{
#if VSM_GENERATE_STATS
	OutStatsBuffer[Index] = Value;
#endif
}
void StatsBufferInterlockedAdd(uint Index, uint Value)
{
#if VSM_GENERATE_STATS
	InterlockedAdd(OutStatsBuffer[Index], Value);
#endif
}

// Type of input data consume by the page allocation (i.e., data read from the source buffer: Gbuffer, HairStrands data, ...)
#define INPUT_TYPE_GBUFFER 0
#define INPUT_TYPE_HAIRSTRANDS 1

// Flags generated by per-pixel pass to determine which pages are required to provide shadow for the visible geometry
RWStructuredBuffer<uint> OutPageRequestFlags;

StructuredBuffer<int> DirectionalLightIds;

float ResolutionLodBiasLocal;
float PageDilationBorderSize;
uint InputType;
uint bCullBackfacingPixels;

// Convenience to group up a bunch of data computed for a screen pixel
struct FScreenPixelData
{
	// Note: Actual world position (not pre-translated)
	float3 WorldPosition;
	float SceneDepth;
};

float2 CalcScreenUV(uint2 PixelPos)
{
	return (float2(PixelPos.xy) + View.ViewRectMin.xy + 0.5f) * View.BufferSizeAndInvSize.zw;
}

// Use an explicit DeviceZ value for this pixel
FScreenPixelData GetScreenPixelData(uint2 PixelPos, float DeviceZ)
{
	FScreenPixelData Data;
	Data.SceneDepth = ConvertFromDeviceZ(DeviceZ);

	//float4 ClipPosition = float4(((CalcScreenUV(PixelPos) - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy), DeviceZ, 1.0f);
	//float4 TranslatedWorldH = mul(ClipPosition, View.ClipToTranslatedWorld);
	//float3 TranslatedWorldPosition = TranslatedWorldH.xyz / TranslatedWorldH.w;

	const float4 SvPosition = float4( float2( PixelPos ) + 0.5, DeviceZ, 1.0f );
	const float3 TranslatedWorldPosition = SvPositionToTranslatedWorld( SvPosition );

	// Subtract the view pre-translation to get back to world space
	Data.WorldPosition = TranslatedWorldPosition - LWCHackToFloat(PrimaryView.PreViewTranslation);

	return Data;
}

uint CalcMipLevelLocal(float Footprint)
{
	float MipLevelFloat = log2(Footprint) + ResolutionLodBiasLocal;
	uint MipLevel = uint(max(floor(MipLevelFloat), 0.0f));
	return min(MipLevel, (VSM_MAX_MIP_LEVELS - 1U));
}

uint GetMipLevelLocal(int VirtualShadowMapId, float3 WorldPosition, float SceneDepth)
{
	float Footprint = float(VSM_VIRTUAL_MAX_RESOLUTION_XY);
	FVirtualShadowMapProjectionShaderData ProjectionData = GetVirtualShadowMapProjectionData(VirtualShadowMapId);

	{
		// Compute footprint by projecting the approximate size of a camera pixel at the given depth to shadow space
		// NOTE: This doesn't take the screen XY position/FOV into account, which may or may not be desirable.
		
		// TODO: Roll into a uniform
		float2 RadiusXY = 1.0f / (View.ViewSizeAndInvSize.xy * View.ViewToClip._m00_m11);
		float RadiusScreen = min(RadiusXY.x, RadiusXY.y);
		float DepthScale = SceneDepth * View.ViewToClip[2][3] + View.ViewToClip[3][3];

		float RadiusWorld = DepthScale * RadiusScreen;

		float3 TranslatedWorldPosition = WorldPosition + ProjectionData.ShadowPreViewTranslation;
		float4 ShadowUVz = mul(float4(TranslatedWorldPosition, 1.0f), ProjectionData.TranslatedWorldToShadowUVMatrix);

		float4 RadiusClipH = mul(float4(RadiusWorld, 0.0f, ShadowUVz.w, 1.0f), ProjectionData.ShadowViewToClipMatrix);
		float RadiusClip = abs(RadiusClipH.x / RadiusClipH.w);
		Footprint = RadiusClip * float(2 * VSM_VIRTUAL_MAX_RESOLUTION_XY);
	}

	return CalcMipLevelLocal(Footprint);
}

void MarkPage(uint VirtualShadowMapId, uint MipLevel, float3 WorldPosition, float2 PageDilationOffset)
{
	FVirtualShadowMapProjectionShaderData ProjectionData = GetVirtualShadowMapProjectionData(VirtualShadowMapId);
	float4 ShadowUVz = mul(float4(WorldPosition + ProjectionData.ShadowPreViewTranslation, 1.0f), ProjectionData.TranslatedWorldToShadowUVMatrix);
	ShadowUVz.xyz /= ShadowUVz.w;

	// Check overlap vs the shadow map space
	// NOTE: XY test not really needed anymore with the precise cone test in the caller, but we'll leave it for the moment
	bool bInClip = ShadowUVz.w > 0.0f && 
		all(ShadowUVz.xyz <= ShadowUVz.w &&
			ShadowUVz.xyz >= float3(-ShadowUVz.ww, 0.0f));
	if (!bInClip)
	{
		return;
	}

	uint Flags = VSM_ALLOCATED_FLAG | VSM_NON_NANITE_FLAG;

	float2 PageAddressFloat = ShadowUVz.xy * CalcLevelDimsPages(MipLevel);
	uint2 PageAddress = uint2(PageAddressFloat);
	uint PageOffset = CalcPageOffset(VirtualShadowMapId, MipLevel, PageAddress);
	OutPageRequestFlags[PageOffset] = Flags;

	// PageDilationBorderSize == 0 implies PageDilationOffset.xy == 0
	if (PageDilationBorderSize > 0.0f)
	{
		uint2 PageAddress2 = uint2(PageAddressFloat + PageDilationOffset);
		uint PageOffset2 = CalcPageOffset(VirtualShadowMapId, MipLevel, PageAddress2);
		if (PageOffset2 != PageOffset)
		{
			OutPageRequestFlags[PageOffset2] = Flags;
		}
		uint2 PageAddress3 = uint2(max(float2(0, 0), PageAddressFloat - PageDilationOffset));
		uint PageOffset3 = CalcPageOffset(VirtualShadowMapId, MipLevel, PageAddress3);
		if (PageOffset3 != PageOffset)
		{
			OutPageRequestFlags[PageOffset3] = Flags;
		}
	}
}

[numthreads(VSM_DEFAULT_CS_GROUP_XY, VSM_DEFAULT_CS_GROUP_XY, 1)]
void GeneratePageFlagsFromPixels(
	uint3 InGroupId : SV_GroupID,
	uint  GroupIndex : SV_GroupIndex,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
#if PERMUTATION_INPUT_TYPE == INPUT_TYPE_HAIRSTRANDS
	uint2 GroupId		= InGroupId.xy;
	if (HairStrands.bHairTileValid>0)
	{
		const uint TileCount = HairStrands.HairTileCount[HAIRTILE_HAIR_ALL];
		const uint LinearIndex  = InGroupId.x + InGroupId.y * HairStrands.HairTileCountXY.x;
		if (LinearIndex >= TileCount)
		{
			return;
		}
		GroupId = HairStrands.HairTileData[LinearIndex];
	}
#else // PERMUTATION_INPUT_TYPE == INPUT_TYPE_GBUFFER
	const uint2 GroupId = InGroupId.xy;
#endif
	// Morton order within a group so page access/atomics are more coherent and wave-swizzled gradients are possible.
	const uint2 PixelPos = VSM_DEFAULT_CS_GROUP_XY * GroupId.xy + MortonDecode(GroupIndex);
	if (any(PixelPos >= uint2(View.ViewSizeAndInvSize.xy)))
	{
		return;
	}

	float3 WorldPosition = 0;
	half3  WorldNormal   = half3(0, 0, 0);
	float  SceneDepth    = 0;
	bool   bIsValid		 = true;
	bool   bBackfaceCull = bCullBackfacingPixels != 0;
	#if PERMUTATION_INPUT_TYPE == INPUT_TYPE_HAIRSTRANDS
	{
		const float HairDeviceZ = HairStrands.HairOnlyDepthTexture.Load(uint3(PixelPos, 0)).x;
		FScreenPixelData HairPixel = GetScreenPixelData(PixelPos, HairDeviceZ);
		WorldPosition = HairPixel.WorldPosition;
		SceneDepth = HairPixel.SceneDepth;
		bIsValid = HairDeviceZ > 0;
		bBackfaceCull = false;
	}
	#else // PERMUTATION_INPUT_TYPE == INPUT_TYPE_GBUFFER
	{
		FScreenPixelData Pixel = GetScreenPixelData(PixelPos, LookupDeviceZ(CalcScreenUV(PixelPos)));
		WorldPosition = Pixel.WorldPosition;
		SceneDepth = Pixel.SceneDepth;

		FGBufferData GBuffer = GetGBufferDataUint(PixelPos, true);
		WorldNormal = GBuffer.WorldNormal;
		// Excluding unlit to avoid including processing sky dome
		bIsValid = GBuffer.ShadingModelID != SHADINGMODELID_UNLIT;
		bBackfaceCull = bBackfaceCull && !IsSubsurfaceModel(GBuffer.ShadingModelID);
	}
	#endif
	
	if (!bIsValid)
	{
		return;
	}

	// Dither pattern for page dilation
	// We don't need to to check all 8 adjacent pages; as long as there's at least a single pixel near the edge
	// the adjacent one will get mapped. In practice only checking one diagonal seems to work fine and have minimal
	// overhead.
	float2 PageDilationOffset = PageDilationBorderSize * 
		float2(GroupIndex & 1 ? 1.0f : -1.0f,
			   GroupIndex & 2 ? 1.0f : -1.0f);
	
	// Directional lights
	for (uint Index = 0; Index < VirtualShadowMap.NumDirectionalLights; ++Index)
	{
		int ClipmapStartId = DirectionalLightIds[Index];
		FVirtualShadowMapProjectionShaderData BaseProjectionData = GetVirtualShadowMapProjectionData(ClipmapStartId);

#if PERMUTATION_INPUT_TYPE != INPUT_TYPE_HAIRSTRANDS
		// Backface test if requested
		float3 LightDirection = -BaseProjectionData.TranslatedWorldToShadowViewMatrix._13_23_33;
		if (bBackfaceCull && IsBackfaceToDirectionalLight(normalize(WorldNormal), normalize(LightDirection), BaseProjectionData.LightSourceRadius))
		{
			continue;
		}
#endif

		// Possibly use a single shadow projection data for the whole clipmap with just scales/biases for
		// each level (to handle snapping). For now we maintain one per level.
		//int ClipmapLevel = CalcClipmapLevel(length(WorldPosition - ProjectionData.ClipmapWorldOrigin), ClipmapResolutionLodBias);
		const int ClipmapLevel = CalcClipmapLevel(BaseProjectionData, WorldPosition);
		int ClipmapIndex = max(0, ClipmapLevel - BaseProjectionData.ClipmapLevel);
		if (ClipmapIndex < BaseProjectionData.ClipmapLevelCount)
		{
			MarkPage(ClipmapStartId + ClipmapIndex, 0, WorldPosition, PageDilationOffset);
		}
	}

	// Local lights
	{
		uint EyeIndex = 0; // ??
		uint3 GridCoordinate = ComputeLightGridCellCoordinate(PixelPos, SceneDepth, EyeIndex);
		uint GridLinearIndex = ComputeLightGridCellIndex(GridCoordinate, EyeIndex);
		const FCulledLightsGridData CulledLightGridData = GetCulledLightsGrid(GridLinearIndex, EyeIndex);

		LOOP
		for (uint Index = 0; Index < CulledLightGridData.NumLocalLights; ++Index)
		{
			const FLocalLightData LightData = GetLocalLightData(CulledLightGridData.DataStartIndex + Index, EyeIndex);
			const uint LightGridLightIndex = ForwardLightData.CulledLightDataGrid[CulledLightGridData.DataStartIndex + Index];

			// TODO: Can optimize these tests by fusing them together
			// Also do precise cone test, since froxels are pretty coarse at times.
			float3 ToLight = normalize(LightData.LightPositionAndInvRadius.xyz - WorldPosition);
			if (dot(ToLight, LightData.LightDirectionAndShadowMask.xyz) < LightData.SpotAnglesAndSourceRadiusPacked.x)
			{
				continue;
			}

			// TODO: Precise radius test necessary?

#if PERMUTATION_INPUT_TYPE != INPUT_TYPE_HAIRSTRANDS
			// Backface test if requested
			if (bBackfaceCull && IsBackfaceToLocalLight(WorldPosition, WorldNormal, LightData.LightPositionAndInvRadius.xyz, LightData.SpotAnglesAndSourceRadiusPacked.z))
			{
				continue;
			}
#endif
			int VirtualShadowMapId = LightData.VirtualShadowMapId;
			if (VirtualShadowMapId != INDEX_NONE)
			{
				bool bSpotLight = LightData.SpotAnglesAndSourceRadiusPacked.x > -2.0f;
				if( !bSpotLight )
				{
					VirtualShadowMapId += VirtualShadowMapGetCubeFace( -ToLight );
				}

				uint MipLevel = GetMipLevelLocal(VirtualShadowMapId, WorldPosition, SceneDepth);
				MarkPage(VirtualShadowMapId, MipLevel, WorldPosition, PageDilationOffset);
			}
		}
	}
}

uint bMarkCoarsePagesLocal;
uint ClipmapIndexMask;
uint bIncludeNonNaniteGeometry;

[numthreads(VSM_DEFAULT_CS_GROUP_X, 1, 1)]
void MarkCoarsePages(uint3 Index : SV_DispatchThreadID)
{
	int VirtualShadowMapId = int(Index.x);
	if (VirtualShadowMapId >= int(VirtualShadowMap.NumShadowMaps))
	{
		return;
	}

	FVirtualShadowMapProjectionShaderData ProjectionData = GetVirtualShadowMapProjectionData(VirtualShadowMapId);

	// NOTE: Coarse pages are very large and tend to get invalidated a lot due to anything in the scene moving
	// Rendering non-nanite geometry into these pages can be very expensive and thus isn't always desirable.
	uint Flags = VSM_ALLOCATED_FLAG | (bIncludeNonNaniteGeometry != 0 ? VSM_NON_NANITE_FLAG : 0);

	if (ProjectionData.LightType == LIGHT_TYPE_DIRECTIONAL)
	{
		// Idea here is the clipmaps already cover supersets of lower levels
		// Thus to get coarser pages we can just mark the center page(s) offset by a level/LOD bias
		// The limit on how far dense data goes out from the camera then becomes the world space size of the marked page(s) on the coarses clipmap
		// We could of course mark a broader set of pages in the coarses clipmap level, but the effective radius
		// even from just marking a single one is usually already large enough for the systems that need this
		// data (volumetric fog, translucent light volume).
		if (((ClipmapIndexMask >> ProjectionData.ClipmapIndex) & 1) != 0)
		{
			// TODO: Optimize this... can be boiled down to be just in terms of the snap offsets
			float4 ShadowUVz = mul(float4(ProjectionData.ClipmapWorldOrigin + ProjectionData.ShadowPreViewTranslation, 1.0f), ProjectionData.TranslatedWorldToShadowUVMatrix);
			float2 VirtualTexelAddressFloat = ShadowUVz.xy * float(CalcLevelDimsTexels(0));
			float2 PageAddressFloat = VirtualTexelAddressFloat * float(1.0f / VSM_PAGE_SIZE);
			// NOTE: Page addresses round down/truncate normally, so grab the surrounding 4
			int4 PageAddressLowHigh = int4(floor(PageAddressFloat - 0.5f), ceil(PageAddressFloat - 0.5f));

			OutPageRequestFlags[CalcPageOffset(VirtualShadowMapId, 0, PageAddressLowHigh.xy)] = Flags;
			OutPageRequestFlags[CalcPageOffset(VirtualShadowMapId, 0, PageAddressLowHigh.xw)] = Flags;
			OutPageRequestFlags[CalcPageOffset(VirtualShadowMapId, 0, PageAddressLowHigh.zy)] = Flags;
			OutPageRequestFlags[CalcPageOffset(VirtualShadowMapId, 0, PageAddressLowHigh.zw)] = Flags;
		}
	}
	else if (bMarkCoarsePagesLocal != 0)
	{
		// Mark last mip
		uint PageOffset = CalcPageOffset(VirtualShadowMapId, VSM_MAX_MIP_LEVELS - 1, uint2(0, 0));
		OutPageRequestFlags[PageOffset] = Flags;
	}
}



RWStructuredBuffer<uint> OutHPageFlags;
RWStructuredBuffer<uint4> PageRectBoundsOut;

[numthreads(VSM_DEFAULT_CS_GROUP_X, 1, 1)]
void InitPageRectBounds(uint3 Index : SV_DispatchThreadID)
{
	if (Index.x < VSM_MAX_MIP_LEVELS * VirtualShadowMap.NumShadowMaps)
	{
		PageRectBoundsOut[Index.x] = uint4(VSM_LEVEL0_DIM_PAGES_XY, VSM_LEVEL0_DIM_PAGES_XY, 0, 0);
	}
}

/**
 * One thread per page table flag entry, one vertical grid row per shadow map
 */
[numthreads(VSM_DEFAULT_CS_GROUP_X, 1, 1)]
void GenerateHierarchicalPageFlags(uint2 ThreadId : SV_DispatchThreadID, uint2 GroupId : SV_GroupID)
{
	// early out any overflowing threads.
	if (ThreadId.x >= VSM_PAGE_TABLE_SIZE)
	{
		return;
	}

	uint PageTableEntryIndex = ThreadId.x;
	// Use the group ID to ensure the compiler knows it is scalar / uniform
	uint ShadowMapID = GroupId.y;
	uint GlobalPageTableEntryIndex = ShadowMapID * VSM_PAGE_TABLE_SIZE + PageTableEntryIndex;
	// If the flag is set, let's get on with it

	uint Flag = PageFlags[GlobalPageTableEntryIndex];
	if (Flag)
	{
		// find the mip-level for this thread.
		uint MipLevel = 0;
		UNROLL
		for (MipLevel = 0; MipLevel < VSM_MAX_MIP_LEVELS - 1; ++MipLevel)
		{
			if (PageTableEntryIndex < CalcLevelOffsets( MipLevel + 1))
			{
				break;
			}
		}
		uint Level0RowMask = ((1U << VSM_LOG2_LEVEL0_DIM_PAGES_XY) - 1U);
		// Offset within level
		uint PageTableLevelOffset = PageTableEntryIndex - CalcLevelOffsets(MipLevel);
		// Coordinate within Mip Level
		uint PX = PageTableLevelOffset & (Level0RowMask >> MipLevel);
		uint PY = PageTableLevelOffset >> (VSM_LOG2_LEVEL0_DIM_PAGES_XY - MipLevel);

		// Compute the min/max rect of active pages
		uint PageBoundIndex = ShadowMapID * VSM_MAX_MIP_LEVELS + MipLevel;
		InterlockedMin(PageRectBoundsOut[PageBoundIndex].x, PX);
		InterlockedMin(PageRectBoundsOut[PageBoundIndex].y, PY);
		InterlockedMax(PageRectBoundsOut[PageBoundIndex].z, PX);
		InterlockedMax(PageRectBoundsOut[PageBoundIndex].w, PY);

		// Loop over H flag levels, this builds a mip pyramid over _each_ mip level in the page table
		// the 0-th level in this hiearchy is the page table mip level itself.
		uint MaxHLevel = VSM_MAX_MIP_LEVELS - MipLevel;
		uint HLevelSizePages = uint(VSM_LEVEL0_DIM_PAGES_XY) >> MipLevel;
		// Note: starting from 1 as level 0 is the ordinary flag mip level
		for (uint HMipLevel = 1U; HMipLevel < MaxHLevel; ++HMipLevel)
		{
			HLevelSizePages >>= 1U;
			PX >>= 1U;
			PY >>= 1U;
			uint HPageFlagOffset = ShadowMapID * VirtualShadowMap.HPageTableSize
				+ CalcHPageFlagLevelOffsets(MipLevel)
				+ CalcLevelOffsets(HMipLevel + MipLevel) 
				- CalcLevelOffsets(MipLevel + 1U) 
				+ PY * HLevelSizePages + PX;

			uint PreviousValue = 0;
			InterlockedOr(OutHPageFlags[HPageFlagOffset], Flag, PreviousValue);

			// If this was already the value, then whoever did that will continue up the hierarhcy, best of luck!
			if (PreviousValue == Flag)
			{
				break;
			}
		}
	}
}

// Page flags generated by page allocation to indicate state to rendering passes (i.e., present / invalid)
StructuredBuffer<uint> PageRequestFlags;
RWStructuredBuffer<uint> OutPageFlags;
RWStructuredBuffer<uint> OutPageTable;
RWStructuredBuffer<FPhysicalPageMetaData> OutPhysicalPageMetaData;
// List of free page indices + counter (last element @ index MaxPhysicalPages)
RWStructuredBuffer<int> OutFreePhysicalPages;

[numthreads(VSM_DEFAULT_CS_GROUP_X, 1, 1)]
void InitPhysicalPageMetaData(uint3 Index : SV_DispatchThreadID)
{
	FPhysicalPageMetaData MetaData;
	MetaData.Flags = 0;
	MetaData.Age = 0;

	// Because of launch size rounding we might get here.
	if (Index.x < VirtualShadowMap.MaxPhysicalPages)
	{
		OutPhysicalPageMetaData[Index.x] = MetaData;
	}

	// Clear the free page counter
	if (Index.x == 0)
	{
		OutFreePhysicalPages[VirtualShadowMap.MaxPhysicalPages] = 0;
	}
}

/**
 * X = One thread per virtual page, Y dim == NumShadowMaps.
 */
[numthreads(VSM_DEFAULT_CS_GROUP_X, 1, 1)]
void CreateCachedPageMappings(uint2 ThreadId : SV_DispatchThreadID)
{
	if (ThreadId.x >= VSM_PAGE_TABLE_SIZE)
	{
		return;
	}

	const uint PageOffsetInShadowMap = ThreadId.x;
	const uint VirtualShadowMapId = ThreadId.y;
	const uint GlobalPageOffset = VirtualShadowMapId * VSM_PAGE_TABLE_SIZE + PageOffsetInShadowMap;

	uint ResultPageTable = VSM_PHYSICAL_PAGE_INVALID;
	uint ResultPageFlags = 0;

#if HAS_CACHE_DATA
	const uint RequestFlags = PageRequestFlags[GlobalPageOffset];
	if (RequestFlags != 0)
	{
		const uint PrevVirtualShadowMapId = ShadowMapCacheData[VirtualShadowMapId].PrevVirtualShadowMapId;
		if (PrevVirtualShadowMapId != INDEX_NONE)
		{
			uint PrevGlobalOffset = PrevVirtualShadowMapId * VSM_PAGE_TABLE_SIZE + PageOffsetInShadowMap;
			const uint PrevFlags = PrevPageFlags[PrevGlobalOffset];
			bool bPrevPageAllocated = PrevFlags != 0;

			// True if the request matches the cached page in terms of whether it includes nanite geometry
			bool bMatchesNonNanite = (RequestFlags & VSM_NON_NANITE_FLAG) == (PrevFlags & VSM_NON_NANITE_FLAG);

			// True if the page had moving stuff drawn into it
			bool bPrevDynamicPageFlag = PrevDynamicCasterPageFlags[PrevGlobalOffset] != 0;

			// TODO: Move elsewhere most likely
			// stats for those pages who die from moving stuff
			if (bPrevPageAllocated && bPrevDynamicPageFlag)
			{
				StatsBufferInterlockedAdd(2, 1);
			}

			// If it was either rendered or cached previous frame, and not drawn to by a moving thing we may re-use
			if (bPrevPageAllocated && !bPrevDynamicPageFlag && bMatchesNonNanite)
			{
				uint2 PhysicalAddress = ShadowDecodePageTable(PrevPageTable[PrevGlobalOffset]).PhysicalAddress;
				uint PhysicalPageIndex = VSMPhysicalPageAddressToIndex(PhysicalAddress);

				FPhysicalPageMetaData PrevMetaData = PrevPhysicalPageMetaData[PhysicalPageIndex];
				if (PrevMetaData.Flags & VSM_PHYSICAL_PAGE_FLAG_ALLOCATED != 0)
				{
					StatsBufferInterlockedAdd(0, 1);	// Total pages
					StatsBufferInterlockedAdd(1, 1);	// Cached pages

					// Keep the same cached physical page
					// Note that we explicitly do not retain the propogated mip data as that could change this
					// frame, so we always "repropogate" after mapping.
					ResultPageTable = ShadowEncodePageTable(PhysicalAddress);
					// Strip "uncached" from previous flags but otherwise maintain them
					ResultPageFlags = PrevFlags & (~VSM_UNCACHED_FLAG);

					// Update metadata to mark this page as cached
					OutPhysicalPageMetaData[PhysicalPageIndex].Age = PrevMetaData.Age + 1;
					OutPhysicalPageMetaData[PhysicalPageIndex].Flags =
						VSM_PHYSICAL_PAGE_FLAG_ALLOCATED | VSM_PHYSICAL_PAGE_FLAG_CACHED;
				}
			}
		}
	}
#endif

	OutPageTable[GlobalPageOffset] = ResultPageTable;
	OutPageFlags[GlobalPageOffset] = ResultPageFlags;
}


StructuredBuffer<FPhysicalPageMetaData> PhysicalPageMetaData;

[numthreads(VSM_DEFAULT_CS_GROUP_X, 1, 1)]
void PackFreePages(uint PhysicalPageIndex : SV_DispatchThreadID)
{
	if (PhysicalPageIndex >= VirtualShadowMap.MaxPhysicalPages)
	{
		return;
	}

	FPhysicalPageMetaData MetaData = PhysicalPageMetaData[PhysicalPageIndex];
	if (MetaData.Flags == 0)
	{
		// Free page; add to the list
		// NOTE: Counter is the final element of the list
		int FreeListOffset = 0;
		WaveInterlockedAddScalar_(OutFreePhysicalPages[VirtualShadowMap.MaxPhysicalPages], 1, FreeListOffset);
		OutFreePhysicalPages[FreeListOffset] = PhysicalPageIndex;
	}
}

[numthreads(VSM_DEFAULT_CS_GROUP_X, 1, 1)]
void AllocateNewPageMappings(uint2 ThreadId : SV_DispatchThreadID, uint2 GroupId : SV_GroupID)
{
	if (ThreadId.x >= VSM_PAGE_TABLE_SIZE)
	{
		return;
	}

	const uint PageOffsetInShadowMap = ThreadId.x;
	const uint VirtualShadowMapId = ThreadId.y;
	const uint GlobalPageOffset = VirtualShadowMapId * VSM_PAGE_TABLE_SIZE + PageOffsetInShadowMap;

	uint ResultPageTable = VSM_PHYSICAL_PAGE_INVALID;
	uint ResultPageFlags = 0;

	// Only allocate pages we haven't already allocated
	uint RequestFlags = PageRequestFlags[GlobalPageOffset];
	if (RequestFlags != 0 && OutPageFlags[GlobalPageOffset] == 0)
	{
		StatsBufferInterlockedAdd(0, 1);	// Total pages

		// Grab a free page from the list
		int FreeListOffset = 0;
		WaveInterlockedAddScalar_(OutFreePhysicalPages[VirtualShadowMap.MaxPhysicalPages], -1, FreeListOffset);
		// We want the value *after* decrement in this case
		--FreeListOffset;

		if (FreeListOffset >= 0)
		{
			uint PhysicalPageIndex = uint(OutFreePhysicalPages[FreeListOffset]);
			uint2 PhysicalPageAddress = VSMPhysicalIndexToPageAddress(PhysicalPageIndex);

			bool bRequestNonNaniteFlag = (RequestFlags & VSM_NON_NANITE_FLAG) != 0;
			uint Flags = VSM_ALLOCATED_FLAG | VSM_UNCACHED_FLAG | (bRequestNonNaniteFlag ? VSM_NON_NANITE_FLAG : 0);

			// Mark this page as allocated and not cached (needing rendering)
			OutPageTable[GlobalPageOffset] = ShadowEncodePageTable(PhysicalPageAddress);
			OutPageFlags[GlobalPageOffset] = Flags;

			OutPhysicalPageMetaData[PhysicalPageIndex].Flags = VSM_PHYSICAL_PAGE_FLAG_ALLOCATED;
		}
		else
		{
			// We end up here if we're out of physical pages, this means some parts get no physical backing provided.
			// Post this error condition back to the host somehow!
			// Probably want to know if we're getting close even.
		}
	}
}


/**
* One thread per page in level 0, launched as 1d groups, with 2D grid with Y dim ==  NumShadowMaps.
* This is effectively just a big broadcast operation. There are more efficient ways to do this with
* fewer threads and wave ops, but given the page counts just relying on memory coalescing is
* good enough for now.
*/
[numthreads(VSM_DEFAULT_CS_GROUP_X, 1, 1)]
void PropagateMappedMips(uint2 ThreadId : SV_DispatchThreadID, uint2 GroupId : SV_GroupID)
{
	const uint NumLevel0Entries = VSM_LEVEL0_DIM_PAGES_XY * VSM_LEVEL0_DIM_PAGES_XY;
	if (ThreadId.x >= NumLevel0Entries)
	{
		return;
	}

	int VirtualShadowMapID = int(GroupId.y);
	uint PageTableEntryIndex = ThreadId.x;

	uint2 Level0Page;
	Level0Page.x = PageTableEntryIndex & ((1U << VSM_LOG2_LEVEL0_DIM_PAGES_XY) - 1U);
	Level0Page.y = PageTableEntryIndex >> VSM_LOG2_LEVEL0_DIM_PAGES_XY;

	FVirtualShadowMapProjectionShaderData ProjectionData = GetVirtualShadowMapProjectionData(VirtualShadowMapID);

	if (ProjectionData.LightType == LIGHT_TYPE_DIRECTIONAL)
	{
		// Directional lights propagate pages to their coarser/larger clipmap levels (and only use mip0 pages)
		// Each clipmap level is a separate VSM, so we gather any mapped coarser pages as necessary and write only our own page output
		// There's also technically a race similar to below with other threads writing the PT data we are reading,
		// but it's still deterministic as long as we only look at pages with "bThisLODValid".
		// There's some redundant work of course, but this shader is pretty cheap overall

		uint Page0Offset = CalcPageOffset(VirtualShadowMapID, 0, Level0Page);
		FShadowPhysicalPage pPage0 = ShadowDecodePageTable(OutPageTable[Page0Offset]);

		BRANCH
		if (!pPage0.bThisLODValid)
		{
			const int OffsetScale = (VSM_LEVEL0_DIM_PAGES_XY >> 2);
			int2 BaseOffset = OffsetScale * ProjectionData.ClipmapCornerOffset;
			int2 BasePage   = int2(Level0Page) - BaseOffset;

			// Search for first mapped page past this one
			uint RemainingLevels = ProjectionData.ClipmapLevelCount - ProjectionData.ClipmapIndex;
			for (uint ClipmapOffset = 1; ClipmapOffset < RemainingLevels; ++ClipmapOffset)
			{
				const int ClipmapLevelId = VirtualShadowMapID + int(ClipmapOffset);

				FVirtualShadowMapProjectionShaderData LevelProjectionData = GetVirtualShadowMapProjectionData(ClipmapLevelId);								
				int2 LevelOffset = OffsetScale * LevelProjectionData.ClipmapCornerOffset;

				int2 LevelPage = (BasePage + (LevelOffset << ClipmapOffset)) >> ClipmapOffset;

				if (all(LevelPage >= 0) && all(LevelPage < VSM_LEVEL0_DIM_PAGES_XY))
				{
					uint LevelPageOffset = CalcPageOffset(ClipmapLevelId, 0, uint2(LevelPage));
					FShadowPhysicalPage pPage = ShadowDecodePageTable(OutPageTable[LevelPageOffset]);
					if (pPage.bThisLODValid)
					{
						OutPageTable[Page0Offset] = ShadowEncodePageTable(pPage.PhysicalAddress, ClipmapOffset);
						break;
					}
				}
				else
				{
					// TODO: We're off the edge... can this ever even happen in practice given the construction?
				}
			}
		}
	}
	else
	{
		// Local lights propagate pages to their coarser mips
		int MappedPageLevel = -1;
		uint2 MappedPhysicalAddress = 0;
	
		for (int Level = (VSM_MAX_MIP_LEVELS - 1); Level >= 0; --Level)
		{
			uint2 vPage = Level0Page >> Level;
			uint PageOffset = CalcPageOffset(VirtualShadowMapID, Level, vPage);
			FShadowPhysicalPage pPage = ShadowDecodePageTable(OutPageTable[PageOffset]);

			BRANCH
			if (pPage.bThisLODValid)
			{
				// This page is mapped, so leave it alone and propagate downwards
				MappedPageLevel = Level;
				MappedPhysicalAddress = pPage.PhysicalAddress;
			}
			else if( MappedPageLevel >= 0 )
			{
				// This page is not mapped; replace it with our suitably offset parent mapped page
				// Ensure only one thread writes each value to avoid races, but we read on all threads as the broadcast
				// Note that this can race with the other threads reading this value, but since bThisLODValid will
				// always be false on these updated pages the values will be ignored. As long as the writes to the page
				// table are atomic (currently a single DWORD), this is safe.
				if (all((vPage << Level) == Level0Page))
				{
					uint MipOffset = MappedPageLevel - Level;
					OutPageTable[PageOffset] = ShadowEncodePageTable(MappedPhysicalAddress, MipOffset);
				}
			}
		}
	}
}


RWTexture2D<uint> OutPhysicalPagePool;

// TODO: This path obviously can and will be optimized (and likely made indirect again),
// but there is additional complexity to put here first.
[numthreads(16, 16, 1)]
void ClearPhysicalPages(uint2 PixelCoord : SV_DispatchThreadID)
{
	const uint2 PageAddress = PixelCoord.xy >> uint(VSM_LOG2_PAGE_SIZE);
	const uint PageIndex = VSMPhysicalPageAddressToIndex(PageAddress);

	FPhysicalPageMetaData MetaData = OutPhysicalPageMetaData[PageIndex];

	if ((MetaData.Flags & VSM_PHYSICAL_PAGE_FLAG_ALLOCATED) == 0)
	{
		// Page not used, we're done
		//OutPhysicalPagePool[PixelCoord] = 0;
	}
	else if ((MetaData.Flags & VSM_PHYSICAL_PAGE_FLAG_CACHED) != 0)
	{
		// Page cached. Leave the data alone
	}
	else
	{
		// New page, clear
		OutPhysicalPagePool[PixelCoord] = 0;
	}
}
