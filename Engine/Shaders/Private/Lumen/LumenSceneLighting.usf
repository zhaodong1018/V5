// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenCardSceneLighting.usf
=============================================================================*/

#include "../Common.ush"
#include "../BRDF.ush"
#include "LumenCardCommon.ush"
#include "LumenCardTile.ush"
#include "../ShaderPrintCommon.ush"

#ifndef THREADGROUP_SIZE
	#define THREADGROUP_SIZE 1
#endif

#define CARD_UPDATE_CONTEXT_DIRECT_LIGHTING 0
#define CARD_UPDATE_CONTEXT_INDIRECT_LIGHTING 1
#define CARD_UPDATE_CONTEXT_MAX 2

#define PRIORITY_HISTOGRAM_SIZE 128
#define MAX_UPDATE_FREQUENCY 7.0f

RWStructuredBuffer<float4> RWCardPageBuffer;

RWStructuredBuffer<uint> RWDirectLightingCardPageIndexAllocator;
RWStructuredBuffer<uint> RWDirectLightingCardPageIndexData;

RWStructuredBuffer<uint> RWIndirectLightingCardPageIndexAllocator;
RWStructuredBuffer<uint> RWIndirectLightingCardPageIndexData;

RWStructuredBuffer<uint> RWPriorityHistogram;
StructuredBuffer<uint> PriorityHistogram;

// [BucketIndex; NumBucketTiles]
#define MAX_UPDATE_BUCKET_STRIDE 2
RWStructuredBuffer<uint> RWMaxUpdateBucket;
StructuredBuffer<uint> MaxUpdateBucket;

// [NumAllocatedTiles; NumAllocatedTilesInLastBucket]
#define CARD_PAGE_TILE_ALLOCATOR_STRIDE 2
RWStructuredBuffer<uint> RWCardPageTileAllocator;
StructuredBuffer<uint> CardPageTileAllocator;

uint UpdateFrameIndex;
uint FreezeUpdateFrame;
uint CardPageNum;
uint MaxDirectLightingTilesToUpdate;
uint MaxIndirectLightingTilesToUpdate;
float FirstClipmapWorldExtentRcp;

float DirectLightingUpdateFactor;
float IndirectLightingUpdateFactor;

/**
 * Batch clear all resources required for the subsequent card context update pass
 */
[numthreads(THREADGROUP_SIZE, 1, 1)]
void ClearCardUpdateContextCS(
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ElementIndex = DispatchThreadId.x;

	if (ElementIndex < 1)
	{
		RWDirectLightingCardPageIndexAllocator[ElementIndex] = 0;
		RWIndirectLightingCardPageIndexAllocator[ElementIndex] = 0;
	}

	if (ElementIndex < CARD_UPDATE_CONTEXT_MAX * MAX_UPDATE_BUCKET_STRIDE)
	{
		RWMaxUpdateBucket[ElementIndex] = 0;
	}

	if (ElementIndex < CARD_UPDATE_CONTEXT_MAX * CARD_PAGE_TILE_ALLOCATOR_STRIDE)
	{
		RWCardPageTileAllocator[ElementIndex] = 0;
	}

	if (ElementIndex < CARD_UPDATE_CONTEXT_MAX * PRIORITY_HISTOGRAM_SIZE)
	{
		RWPriorityHistogram[ElementIndex] = 0;
	}
}

uint GetMaxTilesToUpdate(uint CardUpdateContext)
{
	return CardUpdateContext == CARD_UPDATE_CONTEXT_DIRECT_LIGHTING ? MaxDirectLightingTilesToUpdate : MaxIndirectLightingTilesToUpdate;
}

uint GetLastLightingUpdateFrameIndex(FLumenCardPageData CardPage, uint CardUpdateContext)
{
	return CardUpdateContext == CARD_UPDATE_CONTEXT_DIRECT_LIGHTING ? CardPage.LastDirectLightingUpdateFrameIndex : CardPage.LastIndirectLightingUpdateFrameIndex;
}

uint GetUpdateFactor(uint CardUpdateContext)
{
	return CardUpdateContext == CARD_UPDATE_CONTEXT_DIRECT_LIGHTING ? DirectLightingUpdateFactor : IndirectLightingUpdateFactor;
}

uint GetNumCardPageTiles(FLumenCardPageData CardPage)
{
	return (CardPage.SizeInTexels.x * CardPage.SizeInTexels.y) / (CARD_TILE_SIZE * CARD_TILE_SIZE);
}

uint GetPriorityBucketIndex(FLumenCardData Card, FLumenCardPageData CardPage, uint CardUpdateContext)
{
	const uint LastLightingUpdateFrameIndex = GetLastLightingUpdateFrameIndex(CardPage, CardUpdateContext);
	const float UpdateFactor = GetUpdateFactor(CardUpdateContext);

	// [1;N]
	uint FramesSinceLastUpdated = UpdateFrameIndex - LastLightingUpdateFrameIndex;

	// [0;MAX_UPDATE_FREQUENCY]
	float Frequency = 1.0f;
	{
		float3 CardSpaceViewPosition = mul(LWCHackToFloat(PrimaryView.WorldCameraOrigin) - Card.Origin, Card.WorldToLocalRotation);
		float3 CardPageLocalCenter;
		float3 CardPageLocalExtent;
		GetCardPageLocalBBox(CardPage, Card, CardPageLocalCenter, CardPageLocalExtent);
		const float DistanceFromViewer = sqrt(ComputeSquaredDistanceFromBoxToPoint(CardPageLocalCenter, CardPageLocalExtent, CardSpaceViewPosition));
		Frequency = MAX_UPDATE_FREQUENCY - clamp(DistanceFromViewer * FirstClipmapWorldExtentRcp, 0.0f, MAX_UPDATE_FREQUENCY);
	}

	uint BucketIndex = 0;
	if (LastLightingUpdateFrameIndex == 0)
	{
		// Special case where page wasn't ever updated, just place into first 8 most important buckets based on the frequency
		BucketIndex = clamp(MAX_UPDATE_FREQUENCY - Frequency, 0.0f, MAX_UPDATE_FREQUENCY);
	}
	else
	{
		// [0;N]
		float UpdateImportance = FramesSinceLastUpdated * (Frequency + 1.0f);

		// Normalize histogram
		UpdateImportance = (PRIORITY_HISTOGRAM_SIZE * UpdateImportance) / (UpdateFactor * (MAX_UPDATE_FREQUENCY + 1.0f));

		// Offset from [1;N] and invert in order to place most important pages in bucket 0
		BucketIndex = PRIORITY_HISTOGRAM_SIZE - 1 - clamp(UpdateImportance - 1, 0, PRIORITY_HISTOGRAM_SIZE - 1);
	}

	return BucketIndex;
}

void BuildUpdatePriorityHistogram(FLumenCardData Card, FLumenCardPageData CardPage, uint NumCardPageTiles, uint CardUpdateContext)
{
	uint PriorityBucketIndex = GetPriorityBucketIndex(Card, CardPage, CardUpdateContext);
	InterlockedAdd(RWPriorityHistogram[CardUpdateContext * PRIORITY_HISTOGRAM_SIZE + PriorityBucketIndex], NumCardPageTiles);
}

/**
 * Iterate over all pages and build a histogram of card update priorities 
 */
[numthreads(THREADGROUP_SIZE, 1, 1)]
void BuildPageUpdatePriorityHistogramCS(
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint IndexInIndexBuffer = DispatchThreadId.x;

	if (IndexInIndexBuffer < CardPageNum)
	{
		uint CardPageIndex = IndexInIndexBuffer;
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex);
		FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);
		const uint NumCardPageTiles = GetNumCardPageTiles(CardPage);

		if (NumCardPageTiles > 0)
		{
			BuildUpdatePriorityHistogram(Card, CardPage, NumCardPageTiles, CARD_UPDATE_CONTEXT_DIRECT_LIGHTING);
			BuildUpdatePriorityHistogram(Card, CardPage, NumCardPageTiles, CARD_UPDATE_CONTEXT_INDIRECT_LIGHTING);
		}
	}
}

void SelectMaxUpdateBucket(uint CardUpdateContext)
{
	const uint MaxTilesToUpdate = GetMaxTilesToUpdate(CardUpdateContext);

	uint UpdateTileSum = 0;
	uint PriorityBucketIndex = 0;
	uint PriorityBucketMaxTiles = MaxTilesToUpdate;

	for (; PriorityBucketIndex < PRIORITY_HISTOGRAM_SIZE; ++PriorityBucketIndex)
	{
		uint TilesPerBucket = PriorityHistogram[CardUpdateContext * PRIORITY_HISTOGRAM_SIZE + PriorityBucketIndex];

		if (UpdateTileSum + TilesPerBucket >= MaxTilesToUpdate)
		{
			PriorityBucketMaxTiles = MaxTilesToUpdate - UpdateTileSum;
			break;
		}

		UpdateTileSum += TilesPerBucket;
	}

	RWMaxUpdateBucket[MAX_UPDATE_BUCKET_STRIDE * CardUpdateContext + 0] = PriorityBucketIndex;
	RWMaxUpdateBucket[MAX_UPDATE_BUCKET_STRIDE * CardUpdateContext + 1] = PriorityBucketMaxTiles;
}

/** 
 * Compute max bucket histogram to update and how many tiles should be updated in that last bucket 
 */
[numthreads(THREADGROUP_SIZE, 1, 1)]
void SelectMaxUpdateBucketCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	if (GroupId.x == 0 && GroupThreadId.x == 0)
	{
		SelectMaxUpdateBucket(CARD_UPDATE_CONTEXT_DIRECT_LIGHTING);
	}
	else if (GroupId.x == 1 && GroupThreadId.x == 0)
	{
		SelectMaxUpdateBucket(CARD_UPDATE_CONTEXT_INDIRECT_LIGHTING);
	}
}

bool BuildCardsUpdateList(
	FLumenCardData Card,
	FLumenCardPageData CardPage,
	uint CardPageIndex,
	uint NumCardPageTiles,
	uint CardUpdateContext,
	RWStructuredBuffer<uint> RWCardPageIndexAllocator,
	RWStructuredBuffer<uint> RWCardPageIndexData)
{
	const uint MaxTilesToUpdate = GetMaxTilesToUpdate(CardUpdateContext);
	const uint MaxUpdateBucketIndex = MaxUpdateBucket[MAX_UPDATE_BUCKET_STRIDE * CardUpdateContext + 0];
	const uint MaxUpdateBucketMaxTiles = MaxUpdateBucket[MAX_UPDATE_BUCKET_STRIDE * CardUpdateContext + 1];

	// Update everything up to the max selected priority bucket
	uint PriorityBucketIndex = GetPriorityBucketIndex(Card, CardPage, CardUpdateContext);
	bool bUpdateThisPage = PriorityBucketIndex <= MaxUpdateBucketIndex;

	if (bUpdateThisPage && PriorityBucketIndex == MaxUpdateBucketIndex)
	{
		// Can't update more than MaxUpdateBucketMaxTiles in the max bucket to preserve the general order
		uint NumAllocatedTilesInMaxUpdateBucket = 0;
		InterlockedAdd(RWCardPageTileAllocator[CARD_PAGE_TILE_ALLOCATOR_STRIDE * CardUpdateContext + 1], NumCardPageTiles, NumAllocatedTilesInMaxUpdateBucket);

		if (!(NumAllocatedTilesInMaxUpdateBucket + NumCardPageTiles <= MaxUpdateBucketMaxTiles))
		{
			bUpdateThisPage = false;
		}
	}

	if (bUpdateThisPage)
	{
		bUpdateThisPage = false;
		uint NumAllocatedTiles = 0;
		InterlockedAdd(RWCardPageTileAllocator[CARD_PAGE_TILE_ALLOCATOR_STRIDE * CardUpdateContext + 0], NumCardPageTiles, NumAllocatedTiles);

		if (NumAllocatedTiles + NumCardPageTiles <= MaxTilesToUpdate)
		{
			uint NextIndex = 0;
			InterlockedAdd(RWCardPageIndexAllocator[0], 1, NextIndex);

			if (NextIndex < CardPageNum)
			{
				RWCardPageIndexData[NextIndex] = CardPageIndex;
				bUpdateThisPage = true;
			}
		}
	}

	return bUpdateThisPage;
}

/**
 * Iterate over all cards and pick first N for update based on the histogram max update bucket
 */
[numthreads(THREADGROUP_SIZE, 1, 1)]
void BuildCardsUpdateListCS(
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint IndexInIndexBuffer = DispatchThreadId.x;

	if (IndexInIndexBuffer < CardPageNum)
	{
		const uint CardPageIndex = IndexInIndexBuffer;
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex);
		FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);
		const uint NumCardPageTiles = GetNumCardPageTiles(CardPage);

		if (NumCardPageTiles > 0)
		{
			bool bUpdatedCardPage = false;

			if (BuildCardsUpdateList(
				Card,
				CardPage,
				CardPageIndex,
				NumCardPageTiles,
				CARD_UPDATE_CONTEXT_DIRECT_LIGHTING,
				RWDirectLightingCardPageIndexAllocator,
				RWDirectLightingCardPageIndexData))
			{
				CardPage.LastDirectLightingUpdateFrameIndex = UpdateFrameIndex;
				bUpdatedCardPage = true;
			}

			if (BuildCardsUpdateList(
				Card,
				CardPage,
				CardPageIndex,
				NumCardPageTiles,
				CARD_UPDATE_CONTEXT_INDIRECT_LIGHTING,
				RWIndirectLightingCardPageIndexAllocator,
				RWIndirectLightingCardPageIndexData))
			{
				CardPage.LastIndirectLightingUpdateFrameIndex = UpdateFrameIndex;
				bUpdatedCardPage = true;
			}

			if (bUpdatedCardPage && FreezeUpdateFrame == 0)
			{
				SetCardPageUpdateData(CardPageIndex, CardPage);
			}
		}
	}
}

RWBuffer<uint> RWDirectLightingCardPageIndexIndirectArgs;
RWBuffer<uint> RWIndirectLightingCardPageIndexIndirectArgs;
StructuredBuffer<uint> DirectLightingCardPageIndexAllocator;
StructuredBuffer<uint> IndirectLightingCardPageIndexAllocator;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void SetCardPageIndexIndirectArgsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	if (DispatchThreadId.x == 0)
	{
		uint NumPageIndices = DirectLightingCardPageIndexAllocator[0];
		RWDirectLightingCardPageIndexIndirectArgs[0] = (NumPageIndices + 63) / 64;
		RWDirectLightingCardPageIndexIndirectArgs[1] = 1;
		RWDirectLightingCardPageIndexIndirectArgs[2] = 1;

		NumPageIndices = IndirectLightingCardPageIndexAllocator[0];
		RWIndirectLightingCardPageIndexIndirectArgs[0] = (NumPageIndices + 63) / 64;
		RWIndirectLightingCardPageIndexIndirectArgs[1] = 1;
		RWIndirectLightingCardPageIndexIndirectArgs[2] = 1;
	}
}

uint LightingStatMode;

void LumenSceneLightingStats(uint CardUpdateContext, StructuredBuffer<uint> CardPageIndexAllocator)
{
	float2 Origin = float2(0.1, 0.1);
	float2 TextPos = Origin;

	TextPos = ShaderPrintNewline(TextPos);

	[loop]
	for (uint BucketIndex = 0; BucketIndex < PRIORITY_HISTOGRAM_SIZE; ++BucketIndex)
	{
		TextPos = ShaderPrint(TextPos, PriorityHistogram[CardUpdateContext * PRIORITY_HISTOGRAM_SIZE + BucketIndex]);

		if ((BucketIndex + 1) % 8 == 0)
		{
			TextPos = ShaderPrintNewline(TextPos);
		}
		else
		{
			TextPos = ShaderPrintSymbol(TextPos, _SPC_);
		}
	}

	const uint MaxUpdateBucketIndex = MaxUpdateBucket[MAX_UPDATE_BUCKET_STRIDE * CardUpdateContext + 0];
	const uint MaxUpdateBucketMaxTiles = MaxUpdateBucket[MAX_UPDATE_BUCKET_STRIDE * CardUpdateContext + 1];

	TextPos = ShaderPrintSymbol(TextPos, _M_);
	TextPos = ShaderPrintSymbol(TextPos, _B_);
	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrint(TextPos, MaxUpdateBucketIndex);
	TextPos = ShaderPrintNewline(TextPos);

	TextPos = ShaderPrintSymbol(TextPos, _M_);
	TextPos = ShaderPrintSymbol(TextPos, _T_);
	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrint(TextPos, MaxUpdateBucketMaxTiles);
	TextPos = ShaderPrintNewline(TextPos);

	TextPos = ShaderPrintSymbol(TextPos, _O_);
	TextPos = ShaderPrintSymbol(TextPos, _U_);
	TextPos = ShaderPrintSymbol(TextPos, _T_);
	TextPos = ShaderPrintNewline(TextPos);

	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrintSymbol(TextPos, _P_);
	TextPos = ShaderPrintSymbol(TextPos, _A_);
	TextPos = ShaderPrintSymbol(TextPos, _G_);
	TextPos = ShaderPrintSymbol(TextPos, _E_);
	TextPos = ShaderPrintSymbol(TextPos, _S_);
	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrint(TextPos, CardPageIndexAllocator[0]);

	TextPos = ShaderPrintNewline(TextPos);
	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrintSymbol(TextPos, _T_);
	TextPos = ShaderPrintSymbol(TextPos, _I_);
	TextPos = ShaderPrintSymbol(TextPos, _L_);
	TextPos = ShaderPrintSymbol(TextPos, _E_);
	TextPos = ShaderPrintSymbol(TextPos, _S_);
	TextPos = ShaderPrintSymbol(TextPos, _SPC_);
	TextPos = ShaderPrint(TextPos, CardPageTileAllocator[CARD_PAGE_TILE_ALLOCATOR_STRIDE * CardUpdateContext + 0]);
}

/** 
 * Print out various stats for debugging surface cache updates
 */
[numthreads(1, 1, 1)]
void LumenSceneLightingStatsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	if (LightingStatMode == 1)
	{
		LumenSceneLightingStats(CARD_UPDATE_CONTEXT_DIRECT_LIGHTING, DirectLightingCardPageIndexAllocator);
	}
	else
	{
		LumenSceneLightingStats(CARD_UPDATE_CONTEXT_INDIRECT_LIGHTING, IndirectLightingCardPageIndexAllocator);
	}
}

RWStructuredBuffer<uint> RWQuadAllocator;
RWStructuredBuffer<uint> RWQuadData;

float4 InfluenceSphere;
float3 LightPosition;
float3 LightDirection;
float LightRadius;
float CosConeAngle;
float SinConeAngle;

void GetCardAABB(FLumenCardData LumenCardData, out float3 WorldCardCenter, out float3 WorldCardExtent)
{
	WorldCardCenter = LumenCardData.Origin;
	WorldCardExtent = mul(abs(LumenCardData.WorldToLocalRotation), LumenCardData.LocalExtent);
}

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 0
#endif

#ifndef SHAPE_TYPE
#define SHAPE_TYPE 0
#endif

uint MaxQuadsPerScatterInstance;
uint MaxCardTilesPerScatterInstance;
uint CardScatterInstanceIndex;

StructuredBuffer<uint> CardPageIndexAllocator;
StructuredBuffer<uint> CardPageIndexData;

uint FrameId;
float CardLightingUpdateFrequencyScale;
uint CardLightingUpdateMinFrequency;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void CullCardPagesToShapeCS(
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint IndexInIndexBuffer = DispatchThreadId.x;

	if (IndexInIndexBuffer < CardPageIndexAllocator[0])
	{
		uint CardPageIndex = CardPageIndexData[IndexInIndexBuffer];
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex);
		if (CardPage.CardIndex >= 0)
		{
			FLightCullingParameters LightCullingParameters = CreateLightCullingParameters(
				InfluenceSphere, LightPosition, LightDirection, LightRadius, CosConeAngle, SinConeAngle);

			FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);
			if (Card.bVisible && DoesLightAffectCardPage(SHAPE_TYPE, LightCullingParameters, CardPage, Card))
			{
				uint QuadDataInsertIndex;
				InterlockedAdd(RWQuadAllocator[CardScatterInstanceIndex], 1, QuadDataInsertIndex);

				if (QuadDataInsertIndex < MaxQuadsPerScatterInstance)
				{
					RWQuadData[CardScatterInstanceIndex * MaxQuadsPerScatterInstance + QuadDataInsertIndex] = CardPageIndex;
				}
			}
		}
	}
}

StructuredBuffer<uint> QuadAllocator;
StructuredBuffer<uint> QuadData;
RWStructuredBuffer<uint> RWCardTileAllocator;
RWStructuredBuffer<uint> RWCardTileData;

groupshared uint SharedTileAllocator;
groupshared uint SharedGlobalTileOffset;

/**
 * Build a coherent list of 8x8 tiles, based on the input list of card pages
 */
[numthreads(THREADGROUP_SIZE, 1, 1)]
void BuildCardTilesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	SharedTileAllocator = 0;
	SharedGlobalTileOffset = 0;

	GroupMemoryBarrierWithGroupSync();

	// Every group works on a single page, which has up to 128 tiles
	// Every thread works on 2x2 tiles in that page
	uint QuadIndex = GroupId.x;
	uint2 TileInQuadBaseCoord = 2 * ZOrder2D(GroupThreadId.x, log2(8));
	uint NumQuads = QuadAllocator[CardScatterInstanceIndex];

	uint PackedTileData[4];
	uint NumPackedTiles = 0;
	uint TileOffset = 0;

	if (QuadIndex < NumQuads)
	{
		uint CardPageIndex = QuadData[CardScatterInstanceIndex * MaxQuadsPerScatterInstance + QuadIndex];

		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex);
		if (CardPage.CardIndex >= 0)
		{
			FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);

			FLightCullingParameters LightCullingParameters = CreateLightCullingParameters(
				InfluenceSphere, LightPosition, LightDirection, LightRadius, CosConeAngle, SinConeAngle);

			const uint2 SizeInTiles = CardPage.SizeInTexels / CARD_TILE_SIZE;

			for (uint LinearTileCoordOffset = 0; LinearTileCoordOffset < 4; ++LinearTileCoordOffset)
			{
				const uint2 TileCoord = TileInQuadBaseCoord + uint2(LinearTileCoordOffset % 2, LinearTileCoordOffset / 2);

				if (all(TileCoord < SizeInTiles))
				{
					FCardTileData CardTile;
					CardTile.CardPageIndex = CardPageIndex;
					CardTile.TileCoord = TileCoord;

					float2 UVMin = float2(CardTile.TileCoord) / SizeInTiles;
					float2 UVMax = float2(CardTile.TileCoord + 1) / SizeInTiles;

					float SwapY = UVMin.y;
					UVMin.y = 1.0f - UVMax.y;
					UVMax.y = 1.0f - SwapY;

					bool bLightAffectsCard = DoesLightAffectCardPageUVRange(SHAPE_TYPE, LightCullingParameters, CardPage, Card, UVMin, UVMax);
					if (bLightAffectsCard)
					{
						PackedTileData[NumPackedTiles] = PackCardTileData(CardTile);
						++NumPackedTiles;
					}
				}
			}

			InterlockedAdd(SharedTileAllocator, NumPackedTiles, TileOffset);
		}
	}

	GroupMemoryBarrierWithGroupSync();

	// Allocate memory
	if (all(GroupThreadId.xy == 0) && SharedTileAllocator > 0)
	{
		uint GlobalTileOffset = 0;
		InterlockedAdd(RWCardTileAllocator[CardScatterInstanceIndex], SharedTileAllocator, GlobalTileOffset);
		SharedGlobalTileOffset = GlobalTileOffset;
	}	

	GroupMemoryBarrierWithGroupSync();

	// Write tiles to memory
	for (uint TileIndex = 0; TileIndex < NumPackedTiles; ++TileIndex)
	{
		RWCardTileData[CardScatterInstanceIndex * MaxCardTilesPerScatterInstance + SharedGlobalTileOffset + TileOffset + TileIndex] = PackedTileData[TileIndex];
	}
}

RWBuffer<uint> RWDrawCardPagesIndirectArgs;
RWBuffer<uint> RWBuildTilesIndirectArgs;

uint MaxScatterInstanceCount;
uint VertexCountPerInstanceIndirect;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void InitializeCardPageIndirectArgsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ScatterInstanceIndex = DispatchThreadId.x;

	if (ScatterInstanceIndex < MaxScatterInstanceCount)
	{
		uint NumQuads = QuadAllocator[ScatterInstanceIndex];

		// FRHIDrawIndirectParameters
		uint ArgOffset = 4 * ScatterInstanceIndex;
		RWDrawCardPagesIndirectArgs[ArgOffset + 0] = VertexCountPerInstanceIndirect;
		RWDrawCardPagesIndirectArgs[ArgOffset + 1] = NumQuads;
		RWDrawCardPagesIndirectArgs[ArgOffset + 2] = 0;
		RWDrawCardPagesIndirectArgs[ArgOffset + 3] = 0;

		// FRHIDispatchIndirectParameters
		ArgOffset = 3 * ScatterInstanceIndex;
		RWBuildTilesIndirectArgs[ArgOffset + 0] = NumQuads;
		RWBuildTilesIndirectArgs[ArgOffset + 1] = 1;
		RWBuildTilesIndirectArgs[ArgOffset + 2] = 1;
	}
}

RWBuffer<uint> RWDrawCardTilesIndirectArgs;
RWBuffer<uint> RWDispatchCardTilesIndirectArgs;

StructuredBuffer<uint> CardTileAllocator;
StructuredBuffer<uint> CardTileData;

Buffer<uint4> RectMinMaxBuffer;
float2 InvRectMinMaxResolution;
float2 IndirectLightingAtlasSize;

void RasterizeToCardsVS(
	uint VertexId : SV_VertexID,
	uint InstanceId : SV_InstanceID, 
	out FCardVSToPS CardInterpolants,
	out float4 OutPosition : SV_POSITION
	)
{
	float2 TexCoord = float2(0.0f, 0.0f);
	TexCoord.x += VertexId == 1 || VertexId == 2 || VertexId == 4 ? 1.0f : 0.0f;
	TexCoord.y += VertexId == 2 || VertexId == 4 || VertexId == 5 ? 1.0f : 0.0f;

	uint QuadIndex = InstanceId.x;
	uint NumQuads = QuadAllocator[CardScatterInstanceIndex];

	CardInterpolants = (FCardVSToPS)0;
	OutPosition = 0;

	if (QuadIndex < NumQuads)
	{
		uint CardPageIndex = QuadData[CardScatterInstanceIndex * MaxQuadsPerScatterInstance + QuadIndex];
		FLumenCardPageData CardPage = GetLumenCardPageData(CardPageIndex);
		FLumenCardData Card = GetLumenCardData(CardPage.CardIndex);

		#if CLAMP_TO_INFLUENCE_SPHERE
		{
			float3 LocalSphereOrigin = mul(InfluenceSphere.xyz - Card.Origin, Card.WorldToLocalRotation);

			float2 InvCardPageUVSize = 1.0f / (CardPage.CardUVRect.zw - CardPage.CardUVRect.xy);

			float2 SphereOriginCardUV = SamplePositonToCardUV(Card, LocalSphereOrigin.xy);
			float2 SphereOriginCardPageUV = (SphereOriginCardUV - CardPage.CardUVRect.xy) * InvCardPageUVSize;

			float2 SphereRadius = 0.5f * (InfluenceSphere.ww / Card.LocalExtent.xy) * InvCardPageUVSize;

			TexCoord = clamp(TexCoord, SphereOriginCardPageUV - SphereRadius, SphereOriginCardPageUV + SphereRadius);
		}
		#endif

		float2 ScreenUV = lerp(CardPage.PhysicalAtlasUVRect.xy, CardPage.PhysicalAtlasUVRect.zw, TexCoord);
		float2 AtlasUV = ScreenUV;

		#if RECT_BUFFER_SRC
		{
			float4 AtlasUVRect = RectMinMaxBuffer[CardPageIndex].xyzw * InvRectMinMaxResolution.xyxy;
			AtlasUV = lerp(AtlasUVRect.xy, AtlasUVRect.zw, TexCoord);
		}
		#endif

		#if RECT_BUFFER_SRC
		{
			float4 AtlasUVRect = RectMinMaxBuffer[QuadIndex].xyzw * InvRectMinMaxResolution.xyxy;
			ScreenUV = lerp(AtlasUVRect.xy, AtlasUVRect.zw, TexCoord);
		}
		#endif

		// When sampling from a downsampled Indirect Lighting atlas we need to appropriately clamp input UVs to prevent bilinear reading outside of the valid area
		float2 CardWidthInTexels = (CardPage.PhysicalAtlasUVRect.zw - CardPage.PhysicalAtlasUVRect.xy) * IndirectLightingAtlasSize;
		float2 ClampBorder = 0.5f / CardWidthInTexels;
		float2 IndirectLightingTexCoord = clamp(TexCoord, ClampBorder, 1.0f - ClampBorder);
		float2 IndirectLightingAtlasUV = lerp(CardPage.PhysicalAtlasUVRect.xy, CardPage.PhysicalAtlasUVRect.zw, IndirectLightingTexCoord);

		float2 ScreenPosition = float2(2.0f, -2.0f) * ScreenUV + float2(-1.0f, 1.0f);
		OutPosition = float4(ScreenPosition, 0, 1);

		float2 QuadCorner = -2.0f * TexCoord + 1.0f;
		CardInterpolants.AtlasUV = AtlasUV;
		CardInterpolants.IndirectLightingAtlasUV = IndirectLightingAtlasUV;
		CardInterpolants.CardUV = lerp(CardPage.CardUVRect.xy, CardPage.CardUVRect.zw, TexCoord);
		CardInterpolants.CardTileIndex = 0;
		CardInterpolants.CardPageIndex = CardPageIndex;
	}
}

void RasterizeToCardTilesVS(
	uint VertexId : SV_VertexID,
	uint InstanceId : SV_InstanceID, 
	out FCardVSToPS CardInterpolants,
	out float4 OutPosition : SV_POSITION
	)
{
	float2 TexCoord = float2(0.0f, 0.0f);
	TexCoord.x += VertexId == 1 || VertexId == 2 || VertexId == 4 ? 1.0f : 0.0f;
	TexCoord.y += VertexId == 2 || VertexId == 4 || VertexId == 5 ? 1.0f : 0.0f;

	uint CardTileIndex = InstanceId.x;
	uint NumCardTiles = CardTileAllocator[CardScatterInstanceIndex];

	CardInterpolants = (FCardVSToPS)0;
	OutPosition = 0;

	if (CardTileIndex < NumCardTiles)
	{
		FCardTileData CardTile = UnpackCardTileData(CardTileData[CardScatterInstanceIndex * MaxCardTilesPerScatterInstance + CardTileIndex]);
		FLumenCardPageData CardPage = GetLumenCardPageData(CardTile.CardPageIndex);

		float2 AtlasUV = CardPage.PhysicalAtlasUVRect.xy + CardPage.PhysicalAtlasUVTexelScale * CARD_TILE_SIZE * (CardTile.TileCoord + TexCoord);
		float2 CardUV = CardPage.CardUVRect.xy + CardPage.CardUVTexelScale * CARD_TILE_SIZE * (CardTile.TileCoord + TexCoord);

		float2 ScreenPosition = float2(2.0f, -2.0f) * AtlasUV + float2(-1.0f, 1.0f);
		OutPosition = float4(ScreenPosition, 0, 1);

		CardInterpolants.AtlasUV = AtlasUV;
		CardInterpolants.IndirectLightingAtlasUV = float2(0.0f, 0.0f);
		CardInterpolants.CardUV = CardUV;
		CardInterpolants.CardTileIndex = CardTileIndex;
		CardInterpolants.CardPageIndex = CardTile.CardPageIndex;
	}
}

Texture2D AlbedoAtlas;
Texture2D EmissiveAtlas;
Texture2D DirectLightingAtlas;
Texture2D IndirectLightingAtlas;
Texture2D OpacityAtlas;

float DiffuseReflectivityOverride;

void CombineLumenSceneLighting(
	FCardVSToPS CardInterpolants,
	out float4 OutFinalLighting : SV_Target0)
{
	float3 Albedo = DecodeSurfaceCacheAlbedo(Texture2DSampleLevel(AlbedoAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz);
	float3 Emissive = Texture2DSampleLevel(EmissiveAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz;
	float3 DirectLighting = Texture2DSampleLevel(DirectLightingAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasUV, 0).xyz;
	float3 IndirectLighting = Texture2DSampleLevel(IndirectLightingAtlas, GlobalBilinearClampedSampler, CardInterpolants.IndirectLightingAtlasUV, 0).xyz;

	if (DiffuseReflectivityOverride > 0.0f)
	{
		float AlbedoMaxComponent = max(Albedo.x, max(Albedo.y, Albedo.z));
		Albedo = saturate(Albedo * max(AlbedoMaxComponent / max(AlbedoMaxComponent, .0001f), 1.0f));
	}

	float3 FinalLighting = (DirectLighting + IndirectLighting) * Diffuse_Lambert(Albedo) + Emissive;

	// Secure again strange values, as we are writing it to a persistent atlas with a feedback loop
	FinalLighting = max(MakeFinite(FinalLighting), float3(0.0f, 0.0f, 0.0f));

	OutFinalLighting = float4(FinalLighting, 0);
}

void ClearLumenCardsPS(
	out float4 Target0 : SV_Target0
#if NUM_TARGETS > 1
	,out float4 Target1 : SV_Target1
#endif
	)
{
	Target0 = float4(0.0f, 0.0f, 0.0f, 0.0f);

	#if NUM_TARGETS > 1
		Target1 = float4(0.0f, 0.0f, 0.0f, 0.0f);
	#endif
}

void ClearLumenCardCapturePS(
	out float4 OutAlbedo : SV_Target0,
	out float4 OutNormals : SV_Target1,
	out float4 OutEmissive : SV_Target2
)
{
	OutAlbedo = float4(0.0f, 0.0f, 0.0f, 0.0f);
	OutNormals = float4(0.5f, 0.5f, 0.0f, 0.0f);
	OutEmissive = float4(0.0f, 0.0f, 0.0f, 0.0f);
}