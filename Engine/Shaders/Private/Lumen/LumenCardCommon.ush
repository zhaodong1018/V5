// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenCardCommon.ush
=============================================================================*/

#pragma once

#include "../OctahedralCommon.ush"

struct FLumenCardData
{
	float3 MeshCardsBoundsCenter;
	float3 MeshCardsBoundsExtent;

	float3x3 WorldToLocalRotation;
	float3 Origin;
	float3 LocalExtent;

	uint2 SizeInPages;
	uint PageTableOffset;

	uint2 HiResSizeInPages;
	uint HiResPageTableOffset;

	// Convert Card's uint ResLevel (card's resolution) to uint2 ResLevelXY (each side's resolution)
	uint2 ResLevelToResLevelXYBias;

	bool bVisible;
};

#if USE_LUMEN_CARD_DATA_BUFFER
	StructuredBuffer<float4> LumenCardDataBuffer;	
#else
	#define LumenCardDataBuffer LumenCardScene.CardData
#endif

// Stride of a single cards's data in float4's, must match C++
#define LUMEN_CARD_DATA_STRIDE 7
#define LUMEN_CARD_PAGE_DATA_STRIDE 5

// Fetch from scene card buffer
// Note: layout must match FLumenCardData in C++
FLumenCardData GetLumenCardData(uint CardId)
{
	FLumenCardData CardData = (FLumenCardData)0;

	uint BaseOffset = CardId * LUMEN_CARD_DATA_STRIDE;
	float4 Vector0 = LumenCardDataBuffer[BaseOffset + 0];
	float4 Vector1 = LumenCardDataBuffer[BaseOffset + 1];
	float4 Vector2 = LumenCardDataBuffer[BaseOffset + 2];
	float4 Vector3 = LumenCardDataBuffer[BaseOffset + 3];
	float4 Vector4 = LumenCardDataBuffer[BaseOffset + 4];
	float4 Vector5 = LumenCardDataBuffer[BaseOffset + 5];
	float4 Vector6 = LumenCardDataBuffer[BaseOffset + 6];

	CardData.WorldToLocalRotation[0] = Vector0.xyz;
	CardData.WorldToLocalRotation[1] = Vector1.xyz;
	CardData.WorldToLocalRotation[2] = Vector2.xyz;
	CardData.Origin = float3(Vector0.w, Vector1.w, Vector2.w);

	CardData.LocalExtent = abs(Vector3.xyz);
	CardData.ResLevelToResLevelXYBias.x = (asuint(Vector3.w) >> 0) & 0xFF;
	CardData.ResLevelToResLevelXYBias.y = (asuint(Vector3.w) >> 8) & 0xFF;
	CardData.bVisible = asuint(Vector3.w) & (1 << 16);

	CardData.SizeInPages.x = (asuint(Vector4.x) >> 0) & 0xFFFF;
	CardData.SizeInPages.y = (asuint(Vector4.x) >> 16) & 0xFFFF;
	CardData.PageTableOffset = asuint(Vector4.y);
	CardData.HiResSizeInPages.x = (asuint(Vector4.z) >> 0) & 0xFFFF;
	CardData.HiResSizeInPages.y = (asuint(Vector4.z) >> 16) & 0xFFFF;
	CardData.HiResPageTableOffset = asuint(Vector4.w);

	CardData.MeshCardsBoundsCenter = Vector5.xyz;
	CardData.MeshCardsBoundsExtent = Vector6.xyz;

	return CardData;
}

struct FLumenCardPageData
{
	uint CardIndex;
	bool bMapped;

	uint ResLevelPageTableOffset;
	uint2 ResLevelSizeInTiles;

	float2 SizeInTexels;
	float2 PhysicalAtlasCoord;

	float4 CardUVRect;
	float4 PhysicalAtlasUVRect;
	float2 CardUVTexelScale;
	float2 PhysicalAtlasUVTexelScale;

	uint LastDirectLightingUpdateFrameIndex;
	uint LastIndirectLightingUpdateFrameIndex;
};

RWStructuredBuffer<float4> RWLumenCardPageDataBuffer;
#if USE_RW_LUMEN_CARD_PAGE_DATA_BUFFER
	#define LumenCardPageDataBuffer RWLumenCardPageDataBuffer
#else
	#define LumenCardPageDataBuffer LumenCardScene.CardPageData
#endif

// Note: layout must match FLumenCardPageData in C++
FLumenCardPageData GetLumenCardPageData(uint CardPageId)
{
	FLumenCardPageData CardPageData = (FLumenCardPageData) 0;

	uint BaseOffset = CardPageId * LUMEN_CARD_PAGE_DATA_STRIDE;
	float4 Vector0 = LumenCardPageDataBuffer[BaseOffset + 0];
	float4 Vector1 = LumenCardPageDataBuffer[BaseOffset + 1];
	float4 Vector2 = LumenCardPageDataBuffer[BaseOffset + 2];
	float4 Vector3 = LumenCardPageDataBuffer[BaseOffset + 3];
	float4 Vector4 = LumenCardPageDataBuffer[BaseOffset + 4];

	CardPageData.CardIndex = asuint(Vector0.x);
	CardPageData.ResLevelPageTableOffset = asuint(Vector0.y);
	CardPageData.SizeInTexels = Vector0.zw;
	CardPageData.CardUVRect = Vector1;
	CardPageData.PhysicalAtlasUVRect = Vector2;
	CardPageData.CardUVTexelScale = Vector3.xy;
	CardPageData.ResLevelSizeInTiles = asuint(Vector3.zw);

	CardPageData.LastDirectLightingUpdateFrameIndex = asuint(Vector4.x);
	CardPageData.LastIndirectLightingUpdateFrameIndex = asuint(Vector4.y);

	// Derived properties
	CardPageData.bMapped = CardPageData.SizeInTexels.x > 0;
	CardPageData.PhysicalAtlasCoord = CardPageData.PhysicalAtlasUVRect.xy * LumenCardScene.PhysicalAtlasSize;
	CardPageData.PhysicalAtlasUVTexelScale = LumenCardScene.InvPhysicalAtlasSize;

	return CardPageData;
}

// Store only card page update data
void SetCardPageUpdateData(uint CardPageId, FLumenCardPageData CardPageData)
{
	// Note: layout must match FLumenCardPageData in C++

	uint4 Vector4;
	Vector4.x = CardPageData.LastDirectLightingUpdateFrameIndex;
	Vector4.y = CardPageData.LastIndirectLightingUpdateFrameIndex;
	Vector4.z = 0;
	Vector4.w = 0;

	uint BaseOffset = CardPageId * LUMEN_CARD_PAGE_DATA_STRIDE;
	RWLumenCardPageDataBuffer[BaseOffset + 4] = asfloat(Vector4);
}

struct FCardVSToPS
{
	float2 AtlasUV : ATTRIBUTE0;
	float2 IndirectLightingAtlasUV : ATTRIBUTE1;
	float2 CardUV : ATTRIBUTE2;
	nointerpolation uint CardTileIndex : CARD_TILE_INDEX;
	nointerpolation uint CardPageIndex : CARD_PAGE_INDEX;
};

// Stride of mesh cards data, must match C++
#define LUMEN_MESH_CARDS_DATA_STRIDE 8
#define LUMEN_INVALID_CARD_INDEX 0xFFFFFFFF

struct FLumenMeshCardsData
{
	float4x4 LocalToWorld;
	float4x4 WorldToLocal;

	uint NumCards;
	uint CardOffset;

	uint CardLookup[6];
};

// Note: layout must match FLumenMeshCardsData in C++
FLumenMeshCardsData GetLumenMeshCardsData(uint MeshCardsId)
{
	uint BaseOffset = MeshCardsId * LUMEN_MESH_CARDS_DATA_STRIDE;

	FLumenMeshCardsData MeshCardsData;

	float4 M0 = LumenCardScene.MeshCardsData[BaseOffset + 0];
	float4 M1 = LumenCardScene.MeshCardsData[BaseOffset + 1];
	float4 M2 = LumenCardScene.MeshCardsData[BaseOffset + 2];
	MeshCardsData.LocalToWorld = transpose(float4x4(M0, M1, M2, float4(0.0f, 0.0f, 0.0f, 1.0f)));

	M0 = LumenCardScene.MeshCardsData[BaseOffset + 3];
	M1 = LumenCardScene.MeshCardsData[BaseOffset + 4];
	M2 = LumenCardScene.MeshCardsData[BaseOffset + 5];
	MeshCardsData.WorldToLocal = transpose(float4x4(M0, M1, M2, float4(0.0f, 0.0f, 0.0f, 1.0f)));

	uint4 V3 = asuint(LumenCardScene.MeshCardsData[BaseOffset + 6]);
	uint4 V4 = asuint(LumenCardScene.MeshCardsData[BaseOffset + 7]);
	MeshCardsData.CardOffset = V3.x;
	MeshCardsData.NumCards = V3.y;
	MeshCardsData.CardLookup[0] = V3.z;
	MeshCardsData.CardLookup[1] = V3.w;
	MeshCardsData.CardLookup[2] = V4.x;
	MeshCardsData.CardLookup[3] = V4.y;
	MeshCardsData.CardLookup[4] = V4.z;
	MeshCardsData.CardLookup[5] = V4.w;

	return MeshCardsData;
}

float3 GetCardLocalPosition(FLumenCardData Card, float2 CardUV, float Depth)
{
	CardUV.x = 1.0f - CardUV.x;

	float3 LocalPosition;
	LocalPosition.xy = Card.LocalExtent.xy * (1.0f - 2.0f * CardUV);
	LocalPosition.z = -Card.LocalExtent.z + Depth * 2.0f * Card.LocalExtent.z;

	return LocalPosition;
}

void GetCardLocalBBox(FLumenCardPageData CardPage, FLumenCardData Card, float2 UVMin, float2 UVMax, out float3 CardPageLocalCenter, out float3 CardPageLocalExtent)
{
	float2 CardUVMin = lerp(CardPage.CardUVRect.xw, CardPage.CardUVRect.zy, UVMin);
	float2 CardUVMax = lerp(CardPage.CardUVRect.xw, CardPage.CardUVRect.zy, UVMax);
	float3 CardPageLocalBoxMin = GetCardLocalPosition(Card, CardUVMin, 0.0f);
	float3 CardPageLocalBoxMax = GetCardLocalPosition(Card, CardUVMax, 1.0f);

	CardPageLocalCenter = 0.5f * (CardPageLocalBoxMax + CardPageLocalBoxMin);
	CardPageLocalExtent = 0.5f * (CardPageLocalBoxMax - CardPageLocalBoxMin);
}

void GetCardPageLocalBBox(FLumenCardPageData CardPage, FLumenCardData Card, out float3 CardPageLocalCenter, out float3 CardPageLocalExtent)
{
	GetCardLocalBBox(CardPage, Card, 0, 1, CardPageLocalCenter, CardPageLocalExtent);
}

float3 GetCardWorldPosition(FLumenCardData Card, float2 CardUV, float Depth)
{
	float3 LocalPosition = GetCardLocalPosition(Card, CardUV, Depth);
	float3 WorldPosition = mul(Card.WorldToLocalRotation, LocalPosition) + Card.Origin;
	return WorldPosition;
}

uint2 GetCardPageSizeInTexels(FLumenCardPageData CardPage, uint2 AtlasSize)
{
	float2 AtlasSizeInUV = CardPage.PhysicalAtlasUVRect.zw - CardPage.PhysicalAtlasUVRect.xy;
	return uint2(AtlasSizeInUV * AtlasSize);
}

float2 CardPageUVToCardUV(FLumenCardPageData CardPage, float2 CardPageUV)
{
	float2 CardUV = lerp(CardPage.CardUVRect.xy, CardPage.CardUVRect.zw, CardPageUV);
	return CardUV;
}

float2 CardPageUVToAtlasUV(FLumenCardPageData CardPage, float2 CardPageUV)
{
	float2 AtlasUV = lerp(CardPage.PhysicalAtlasUVRect.xy, CardPage.PhysicalAtlasUVRect.zw, CardPageUV);
	return AtlasUV;
}

float2 SamplePositonToCardUV(FLumenCardData Card, float2 LocalSamplePosition)
{
	float2 CardUV = saturate(float2(+0.5f, -0.5f) * (LocalSamplePosition / Card.LocalExtent.xy) + 0.5f);
	return CardUV;
}

// Return decoded world space normal
float3 DecodeSurfaceCacheNormal(FLumenCardData Card, float2 EncodedNormal)
{
	float3 CardSpaceNormal;
	CardSpaceNormal.xy = EncodedNormal.xy * 2.0f - 1.0f;
	CardSpaceNormal.z = sqrt(max(1.0f - length2(CardSpaceNormal.xy), 0.0001f));
	return mul(Card.WorldToLocalRotation, CardSpaceNormal);
}

// Return decoded albedo
float3 DecodeSurfaceCacheAlbedo(float3 EncodedAlbedo)
{
	return EncodedAlbedo * EncodedAlbedo;
}

bool SphereIntersectCone(float4 SphereCenterAndRadius, float3 ConeVertex, float3 ConeAxis, float ConeAngleCos, float ConeAngleSin)
{
	float3 U = ConeVertex - (SphereCenterAndRadius.w / ConeAngleSin) * ConeAxis;
	float3 D = SphereCenterAndRadius.xyz - U;
	float DSizeSq = dot(D, D);
	float E = dot(ConeAxis, D);

	if (E > 0 && E * E >= DSizeSq * ConeAngleCos * ConeAngleCos)
	{
		D = SphereCenterAndRadius.xyz - ConeVertex;
		DSizeSq = dot(D, D);
		E = -dot(ConeAxis, D);

		if (E > 0 && E * E >= DSizeSq * ConeAngleSin * ConeAngleSin)
		{
			return DSizeSq <= SphereCenterAndRadius.w * SphereCenterAndRadius.w;
		}
		else
		{
			return true;
		}
	}

	return false;
}

struct FLightCullingParameters
{
	float4 InfluenceSphere;
	float3 LightPosition;
	float3 LightDirection;
	float LightRadius;
	float CosConeAngle;
	float SinConeAngle;
};

FLightCullingParameters CreateLightCullingParameters(
	float4 InfluenceSphere,
	float3 LightPosition,
	float3 LightDirection,
	float LightRadius,
	float CosConeAngle,
	float SinConeAngle
)
{
	FLightCullingParameters Parameters;
	Parameters.InfluenceSphere = InfluenceSphere;
	Parameters.LightPosition = LightPosition;
	Parameters.LightDirection = LightDirection;
	Parameters.LightRadius = LightRadius;
	Parameters.CosConeAngle = CosConeAngle;
	Parameters.SinConeAngle = SinConeAngle;

	return Parameters;
}

bool DoesLightAffectCardPageUVRange(uint LightType, FLightCullingParameters LightCullingParameters, FLumenCardPageData CardPage, FLumenCardData Card, float2 UVMin, float2 UVMax)
{
	float3 CardPageLocalCenter;
	float3 CardPageLocalExtent;
	GetCardLocalBBox(CardPage, Card, UVMin, UVMax, CardPageLocalCenter, CardPageLocalExtent);

	float3 CardPageWorldCenter = mul(Card.WorldToLocalRotation, CardPageLocalCenter) + Card.Origin;
	float3 CardPageWorldExtent = mul(abs(Card.WorldToLocalRotation), CardPageLocalExtent);
	float CardPageWorldBoundingSphere = length(CardPageLocalExtent);

	float4 InfluenceSphere = LightCullingParameters.InfluenceSphere;
	float3 LightInfluenceSphereLocalCenter = mul(InfluenceSphere.xyz - Card.Origin, Card.WorldToLocalRotation);
	const float BoxDistanceSq = ComputeSquaredDistanceFromBoxToPoint(CardPageLocalCenter, CardPageLocalExtent, LightInfluenceSphereLocalCenter);
	const bool bCardAffectedByInfluenceSphere = BoxDistanceSq < InfluenceSphere.w* InfluenceSphere.w;

	//uint LightType = LightCullingParameters.GetLightType();
	if (LightType == 0)
	{
		return true;
	}
	else if (LightType == 1)
	{
		// Point light
		return bCardAffectedByInfluenceSphere;
	}
	else if (LightType == 2)
	{
		float3 LightPosition = LightCullingParameters.LightPosition;
		float3 LightDirection = LightCullingParameters.LightDirection;
		float CosConeAngle = LightCullingParameters.CosConeAngle;
		float SinConeAngle = LightCullingParameters.SinConeAngle;
		float LightRadius = LightCullingParameters.LightRadius;

		float ConeAxisDistance = dot(CardPageWorldCenter - LightPosition, LightDirection);
		float2 ConeAxisDistanceMinMax = float2(ConeAxisDistance + CardPageWorldBoundingSphere, ConeAxisDistance - CardPageWorldBoundingSphere);

		// Spot light
		return bCardAffectedByInfluenceSphere
			&& SphereIntersectCone(float4(CardPageWorldCenter, CardPageWorldBoundingSphere), LightPosition, LightDirection, CosConeAngle, SinConeAngle)
			&& ConeAxisDistanceMinMax.x > 0 && ConeAxisDistanceMinMax.y < LightRadius;
	}
	else if (LightType == 3)
	{
		float3 LightPosition = LightCullingParameters.LightPosition;
		float3 LightDirection = LightCullingParameters.LightDirection;

		// Rect light
		float4 BackPlane = float4(LightDirection, dot(LightPosition, LightDirection));
		float DistanceFromBoxCenterToPlane = dot(BackPlane.xyz, CardPageWorldCenter) - BackPlane.w;
		float MaxExtent = dot(CardPageWorldExtent, abs(BackPlane.xyz));
		bool bInFrontOfPlane = DistanceFromBoxCenterToPlane + MaxExtent > 0.0f;
		return bCardAffectedByInfluenceSphere && bInFrontOfPlane;
	}

	// Error: Unknown light type
	return false;
}

bool DoesLightAffectCardPage(uint LightType, FLightCullingParameters LightCullingParameters, FLumenCardPageData CardPage, FLumenCardData Card)
{
	float2 UVMin = float2(0.0f, 0.0f);
	float2 UVMax = float2(1.0f, 1.0f);
	return DoesLightAffectCardPageUVRange(LightType, LightCullingParameters, CardPage, Card, UVMin, UVMax);
}

float3 GetCardWorldPositionForShadowing(float3 WorldPosition, float3 L, float3 WorldNormal, float SurfaceBias, float SlopeScaledSurfaceBias, float BiasScale)
{
	//@todo DynamicGI - derive from card texel size
	return WorldPosition + L * (SurfaceBias + SlopeScaledSurfaceBias * saturate(1 - dot(L, WorldNormal))) * BiasScale;
}