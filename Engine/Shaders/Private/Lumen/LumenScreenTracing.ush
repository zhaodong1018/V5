// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenScreenTracing.ush
=============================================================================*/

#pragma once

#include "../Common.ush"
#include "../FastMath.ush"
#include "../SceneTextureParameters.ush"

// HZB mip 0 is half res scene depth. To do accurate traces we need to traverse all the way down to full res scene depth, but this adds an incoherent branch on the inner tracing loop.
#ifndef HZB_TRACE_INCLUDE_FULL_RES_DEPTH
#define HZB_TRACE_INCLUDE_FULL_RES_DEPTH 0
#endif

/**
 * Accurate but slow screen trace by traversing the HZB.
 * RayTranslatedWorldOrigin must be a position on-screen
 * RayWorldDirection must be unit length
 * OutScreenUV gives either the hit screen UV or the screen UV of the furthest unoccluded position along the ray, which can be plugged into ComputeRayHitSqrDistance.  
 * MaxIterations has a large impact on performance
 * RelativeDepthThickness is how thick to treat each pixel as.  Larger values cause artifacts as the color value of the pixel gets stretched.
 */
void InternalTraceScreen(
	Texture2D InSceneDepthTexture,
	Texture2D InClosestHZBTexture,
	float2 InHZBBaseTexelSize,
	float4 InHZBUVToScreenUVScaleBias,
	float3 RayTranslatedWorldOrigin, 
	float3 RayWorldDirection,
	float MaxWorldTraceDistance,
	float4 HZBUvFactorAndInvFactor,
	float MaxIterations,
	float RelativeDepthThickness,
	float NumThicknessStepsToDetermineCertainty,
	inout bool bHit,
	inout bool bUncertain,
	inout float3 OutScreenUV)
{
	float3 RayStartScreenUV;
	{
		float4 RayStartClip = mul(float4(RayTranslatedWorldOrigin, 1.0f), View.TranslatedWorldToClip);
		float3 RayStartScreenPosition = RayStartClip.xyz / max(RayStartClip.w, 1.0f);
		RayStartScreenUV = float3((RayStartScreenPosition.xy * float2(0.5f, -0.5f) + 0.5f) * HZBUvFactorAndInvFactor.xy, RayStartScreenPosition.z);
	}
	
	float3 RayEndScreenUV;
	{
		float3 ViewRayDirection = mul(float4(RayWorldDirection, 0.0), View.TranslatedWorldToView).xyz;
		float SceneDepth = mul(float4(RayTranslatedWorldOrigin, 1.0f), View.TranslatedWorldToView).z;
		// Clamps the ray to end at the Z == 0 plane so the end point will be valid in NDC space for clipping
		float RayEndWorldDistance = ViewRayDirection.z < 0.0 ? min(-0.99f * SceneDepth / ViewRayDirection.z, MaxWorldTraceDistance) : MaxWorldTraceDistance;

		float3 RayWorldEnd = RayTranslatedWorldOrigin + RayWorldDirection * RayEndWorldDistance;
		float4 RayEndClip = mul(float4(RayWorldEnd, 1.0f), View.TranslatedWorldToClip);
		float3 RayEndScreenPosition = RayEndClip.xyz / RayEndClip.w;
		RayEndScreenUV = float3((RayEndScreenPosition.xy * float2(0.5f, -0.5f) + 0.5f) * HZBUvFactorAndInvFactor.xy, RayEndScreenPosition.z);

		float2 ScreenEdgeIntersections = LineBoxIntersect(RayStartScreenUV, RayEndScreenUV, float3(0, 0, 0), float3(HZBUvFactorAndInvFactor.xy, 1));

		// Recalculate end point where it leaves the screen
		RayEndScreenUV = RayStartScreenUV + (RayEndScreenUV - RayStartScreenUV) * ScreenEdgeIntersections.y;
	}

	float BaseMipLevel = HZB_TRACE_INCLUDE_FULL_RES_DEPTH ? -1 : 0;
	float MipLevel = BaseMipLevel;

	// Step out of current tile without hit test to avoid self-intersection
	// This is necessary because HZB mip 0 is the closest of the 2x2 depths, and because HZB is stored in 16 bit fp
	bool bStepOutOfCurrentTile = true;

	if (bStepOutOfCurrentTile)
	{
		float2 HZBTileSize = exp2(MipLevel) * InHZBBaseTexelSize;
		float2 BiasedUV = RayStartScreenUV.xy;
		float3 HZBTileMin = float3(floor(BiasedUV.xy / HZBTileSize) * HZBTileSize, 0.0f);
		float3 HZBTileMax = float3(HZBTileMin.xy + HZBTileSize, 1);
		float2 TileIntersections = LineBoxIntersect(RayStartScreenUV, RayEndScreenUV, HZBTileMin, HZBTileMax);

		{
			float3 RayTileHit = RayStartScreenUV + (RayEndScreenUV - RayStartScreenUV) * TileIntersections.y;
			RayStartScreenUV = RayTileHit;
		}
	}

	bHit = false;
	bUncertain = false;

	float RayLength2D = length(RayEndScreenUV.xy - RayStartScreenUV.xy);
	float2 RayDirectionScreenUV = (RayEndScreenUV.xy - RayStartScreenUV.xy) / max(RayLength2D, .0001f);
	float3 RayScreenUV = RayStartScreenUV;
	float NumIterations = 0;
	
	// Stackless HZB traversal
	while (MipLevel >= BaseMipLevel && NumIterations < MaxIterations)
	{
		float2 HZBTileSize = exp2(MipLevel) * InHZBBaseTexelSize;
		// RayScreenUV is on a tile boundary due to bStepOutOfCurrentTile
		// Offset the UV along the ray direction so it always quantizes to the next tile
		float2 BiasedUV = RayScreenUV.xy + .01f * RayDirectionScreenUV.xy * HZBTileSize;
		float3 HZBTileMin = float3(floor(BiasedUV / HZBTileSize) * HZBTileSize, 0.0f);
		float3 HZBTileMax = float3(HZBTileMin.xy + HZBTileSize, 1);
		float2 TileIntersections = LineBoxIntersect(RayStartScreenUV, RayEndScreenUV, HZBTileMin, HZBTileMax);
		float3 RayTileHit = RayStartScreenUV + (RayEndScreenUV - RayStartScreenUV) * TileIntersections.y;

		float TileZ;
		float AvoidSelfIntersectionZScale = 1.0f;

#if HZB_TRACE_INCLUDE_FULL_RES_DEPTH
		if (MipLevel < 0)
		{
			TileZ = InSceneDepthTexture.SampleLevel(GlobalPointClampedSampler, BiasedUV * InHZBUVToScreenUVScaleBias.xy + InHZBUVToScreenUVScaleBias.zw, 0).r;
		}
		else
#endif
		{
			TileZ = InClosestHZBTexture.SampleLevel(GlobalPointClampedSampler, BiasedUV, MipLevel).x;
			// Heuristic to avoid incorrect self-intersection because HZB mip 0 is actually the closest of the 2x2 depths, and because HZB is only 16 bit fp
			AvoidSelfIntersectionZScale = lerp(.99f, 1.0f, saturate(TileIntersections.y * 10.0f));
		}

		if (RayTileHit.z > TileZ * AvoidSelfIntersectionZScale)
		{
			RayScreenUV = RayTileHit;
			MipLevel++;

			if (TileIntersections.y == 1.0f)
			{
				// Ray did not intersect HZB tile, no hit
				MipLevel = BaseMipLevel - 1;
			}
		}
		else
		{
			if (abs(MipLevel - BaseMipLevel) < .1f)
			{
				RayScreenUV = RayStartScreenUV + (RayEndScreenUV - RayStartScreenUV) * TileIntersections.x;
				
				bHit = true;
				float IntersectionDepth = ConvertFromDeviceZ(TileZ);
				float RayTileEnterZ = RayStartScreenUV.z + (RayEndScreenUV.z - RayStartScreenUV.z) * TileIntersections.x;
				bUncertain = (ConvertFromDeviceZ(RayTileEnterZ) - IntersectionDepth) / max(IntersectionDepth, .00001f) > RelativeDepthThickness;
			}

			MipLevel--;
		}

		NumIterations++;
	}

	// Linear steps to determine feature thickness along the ray, to reject hits behind very thin surfaces (grass / hair / foliage)
	if (bHit && !bUncertain && NumThicknessStepsToDetermineCertainty > 0)
	{
		float ThicknessSearchMipLevel = 0.0f;
		float MipNumTexels = exp2(ThicknessSearchMipLevel);
		float2 HZBTileSize = MipNumTexels * InHZBBaseTexelSize;
		float NumSteps = NumThicknessStepsToDetermineCertainty / MipNumTexels;
		float ThicknessSearchEndTime = min(length(RayDirectionScreenUV * HZBTileSize * NumSteps) / length(RayEndScreenUV.xy - RayScreenUV.xy), 1.0f);

		for (float I = 0; I < NumSteps; I++)
		{
			float3 SampleUV = RayScreenUV + (I / NumSteps) * ThicknessSearchEndTime * (RayEndScreenUV - RayScreenUV);

			if (all(SampleUV.xy > 0 && SampleUV.xy < HZBUvFactorAndInvFactor.xy))
			{
				float SampleTileZ = InClosestHZBTexture.SampleLevel(GlobalPointClampedSampler, SampleUV.xy, ThicknessSearchMipLevel).x;

				if (SampleUV.z > SampleTileZ)
				{
					bUncertain = true;
				}
			}
		}
	}

	// Debug - visualize clipped endpoints
	//RayScreenUV = RayEndScreenUV;
	//bHit = bUncertain;

	// Output in GBuffer SceneUV space for xy
	OutScreenUV.xy = RayScreenUV.xy * InHZBUVToScreenUVScaleBias.xy + InHZBUVToScreenUVScaleBias.zw;
	OutScreenUV.z = RayScreenUV.z;
}

Texture2D ClosestHZBTexture;
float2 HZBBaseTexelSize;
float4 HZBUVToScreenUVScaleBias;

void TraceScreen(
	float3 RayTranslatedWorldOrigin,
	float3 RayWorldDirection,
	float MaxWorldTraceDistance,
	float4 HZBUvFactorAndInvFactor,
	float MaxIterations,
	float RelativeDepthThickness,
	float NumThicknessStepsToDetermineCertainty,
	inout bool bHit,
	inout bool bUncertain,
	inout float3 OutScreenUV)
{
	InternalTraceScreen(
		SceneDepthTexture,
		ClosestHZBTexture,
		HZBBaseTexelSize,
		HZBUVToScreenUVScaleBias,
		RayTranslatedWorldOrigin,
		RayWorldDirection,
		MaxWorldTraceDistance,
		HZBUvFactorAndInvFactor,
		MaxIterations,
		RelativeDepthThickness,
		NumThicknessStepsToDetermineCertainty,
		bHit,
		bUncertain,
		OutScreenUV);
} 

float3 GetPrevScreenPosition(float2 ScreenPosition, float2 ScreenUV, float DeviceZ)
{
	float3 HistoryScreenPosition = float3(ScreenPosition, DeviceZ);
	bool bIsDynamicPixel = false;

	{
		float4 ThisClip = float4(HistoryScreenPosition, 1);
		//float4 PrevClip = mul(ThisClip, View.ClipToPrevClip); //<=== doesn't contain AA offsets
		float4 PrevClip = mul(ThisClip, View.ClipToPrevClipWithAA);
		
		float3 PrevScreen = PrevClip.xyz / PrevClip.w;
		float3 Velocity = HistoryScreenPosition - PrevScreen;
		float4 EncodedVelocity = GBufferVelocityTexture.SampleLevel(GlobalPointClampedSampler, ScreenUV, 0);
		bIsDynamicPixel = EncodedVelocity.x > 0.0;

		if (bIsDynamicPixel)
		{
			// Warning: overwriting velocity, this only works if DeviceZ matches what's in the depth buffer
			Velocity = DecodeVelocityFromTexture(EncodedVelocity);
		}

		HistoryScreenPosition -= Velocity;
	}

	return HistoryScreenPosition;
}
