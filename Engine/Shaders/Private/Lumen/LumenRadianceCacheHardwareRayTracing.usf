// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../MonteCarlo.ush"
#include "../MortonCode.ush"
#include "../SceneTextureParameters.ush"

#include "LumenRadianceCacheCommon.ush"
#include "LumenRadianceCacheTracingCommon.ush"
#include "LumenCardCommon.ush"
#include "LumenTracingCommon.ush"
#include "LumenReflectionCommon.ush"

#define TEMP_ATLAS_TRACE_TILE_STRIDE 1024

#if LUMEN_HARDWARE_RAYTRACING
#include "LumenHardwareRayTracingCommon.ush"

#ifndef DIM_LIGHTING_MODE
#define DIM_LIGHTING_MODE LIGHTING_FROM_SURFACE_CACHE
#endif

RaytracingAccelerationStructure TLAS;
RWTexture2D<float4> RWTraceTileRadianceAndHitDistanceTexture;

uint PersistentTracingGroupCount;

RAY_TRACING_ENTRY_RAYGEN(LumenRadianceCacheHardwareRayTracingRGS)
{
	uint2 GroupThreadId = uint2(DispatchRaysIndex().x % RADIANCE_CACHE_TRACE_TILE_SIZE_2D, DispatchRaysIndex().x / RADIANCE_CACHE_TRACE_TILE_SIZE_2D);

	uint TraceTileIterationSize = (ProbeTraceTileAllocator[0] + PersistentTracingGroupCount - 1) / PersistentTracingGroupCount;
	for (uint TraceTileIteration = 0; TraceTileIteration < TraceTileIterationSize; ++TraceTileIteration)
	{
		uint TraceTileGroupIndex = DispatchRaysIndex().y;
		uint TraceTileIndex = TraceTileIteration * PersistentTracingGroupCount + TraceTileGroupIndex;
		if (TraceTileIndex >= ProbeTraceTileAllocator[0])
		{
			return;
		}

		uint2 TraceTileCoord;
		uint TraceTileLevel;
		uint ProbeTraceIndex;
		UnpackTraceTileInfo(ProbeTraceTileData[TraceTileIndex], TraceTileCoord, TraceTileLevel, ProbeTraceIndex);

		float3 ProbeWorldCenter;
		uint ClipmapIndex;
		uint ProbeIndex;
		GetProbeTraceData(ProbeTraceIndex, ProbeWorldCenter, ClipmapIndex, ProbeIndex);

		uint TraceResolution = (RadianceProbeResolution / 2) << TraceTileLevel;
		uint2 ProbeTexelCoord = TraceTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + GroupThreadId.xy;

		if (all(ProbeTexelCoord < TraceResolution))
		{
			float2 ProbeTexelCenter = float2(0.5, 0.5);
			float2 ProbeUV = (ProbeTexelCoord + ProbeTexelCenter) / float(TraceResolution);
			float3 WorldConeDirection = OctahedronToUnitVector(ProbeUV * 2.0 - 1.0);

			float FinalMinTraceDistance = max(MinTraceDistance, GetRadianceProbeTMin(ClipmapIndex));
			float FinalMaxTraceDistance = MaxTraceDistance;

			// Evenly distributing the sphere solid angle among all cones instead of based on Octahedron distortion
			float ConeHalfAngle = acosFast(1.0f - 1.0f / (float)(TraceResolution * TraceResolution));

			RayDesc Ray;
			Ray.Origin = ProbeWorldCenter;
			Ray.Direction = WorldConeDirection;
			Ray.TMin = FinalMinTraceDistance;
			Ray.TMax = FinalMaxTraceDistance;

			FRayCone RayCone = (FRayCone)0;
			RayCone = PropagateRayCone(RayCone, ConeHalfAngle, 0.0);

			const uint LinearCoord = ProbeTexelCoord.y * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + ProbeTexelCoord.x;
			const bool bCullBackFacingTriangles = false;
			FRayTracedLightingContext Context = CreateRayTracedLightingContext(TLAS, RayCone, ProbeTexelCoord, LinearCoord, bCullBackFacingTriangles);

			float3 SampleRadiance = 0.0;
			float SampleHitDistance = MaxHalfFloat;

			FRayTracedLightingResult Result;
			bool bUseMinimalPayload = (DIM_LIGHTING_MODE == LIGHTING_FROM_SURFACE_CACHE);
			if (bUseMinimalPayload)
			{
				Result = TraceAndCalculateRayTracedLightingFromSurfaceCache(Ray, Context);
			}
			else
			{
				Result = TraceAndCalculateRayTracedLighting(Ray, Context, DIM_LIGHTING_MODE);
			}
			SampleHitDistance = Result.TraceHitDistance;
			SampleRadiance = Result.Radiance;

			// Apply environment contribution on miss
			if (!Result.bIsHit)
			{
				FConeTraceResult TraceResult = (FConeTraceResult)0;
				TraceResult.Transparency = 1;
				EvaluateSkyRadianceForCone(Ray.Direction, tan(ConeHalfAngle), TraceResult);
				SampleRadiance = TraceResult.Lighting;
				SampleHitDistance = MaxTraceDistance;
			}

			uint2 WrappedTileCoord = uint2(TraceTileIndex % TEMP_ATLAS_TRACE_TILE_STRIDE, TraceTileIndex / TEMP_ATLAS_TRACE_TILE_STRIDE);
			uint2 OutputIndex = WrappedTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + GroupThreadId;
			RWTraceTileRadianceAndHitDistanceTexture[OutputIndex] = float4(SampleRadiance, min(SampleHitDistance, MaxHalfFloat));
		}
	}
}

#endif // LUMEN_HARDWARE_RAYTRACING

Texture2D<float4> RadianceAndHitDistanceTexture;
uint2 RadianceAndHitDistanceTextureSize;


[numthreads(RADIANCE_CACHE_TRACE_TILE_SIZE_2D, RADIANCE_CACHE_TRACE_TILE_SIZE_2D, 1)]
void SplatRadianceCacheIntoAtlasCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID
)
{
	uint TraceTileIndex = GroupId.y * TRACE_TILE_GROUP_STRIDE + GroupId.x;
	if (TraceTileIndex >= ProbeTraceTileAllocator[0])
	{
		return;
	}

	uint2 TraceTileCoord;
	uint TraceTileLevel;
	uint ProbeTraceIndex;
	UnpackTraceTileInfo(ProbeTraceTileData[TraceTileIndex], TraceTileCoord, TraceTileLevel, ProbeTraceIndex);

	uint TraceResolution = (RadianceProbeResolution / 2) << TraceTileLevel;
	uint2 WrappedTileCoord = uint2(TraceTileIndex % TEMP_ATLAS_TRACE_TILE_STRIDE, TraceTileIndex / TEMP_ATLAS_TRACE_TILE_STRIDE);

	float3 ProbeWorldCenter;
	uint ClipmapIndex;
	uint ProbeIndex;
	GetProbeTraceData(ProbeTraceIndex, ProbeWorldCenter, ClipmapIndex, ProbeIndex);

	uint2 ProbeAtlasBaseCoord = RadianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);

	if (TraceResolution < RadianceProbeResolution)
	{
		uint UpsampleFactor = RadianceProbeResolution / TraceResolution;
		ProbeAtlasBaseCoord += (RADIANCE_CACHE_TRACE_TILE_SIZE_2D * TraceTileCoord + GroupThreadId.xy) * UpsampleFactor;

		uint2 RadianceAndHitDistanceTextureIndex = WrappedTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + GroupThreadId.xy;
		float4 Data = RadianceAndHitDistanceTexture[RadianceAndHitDistanceTextureIndex];
		float3 Lighting = Data.rgb;

		if (any(RadianceAndHitDistanceTextureIndex >= RadianceAndHitDistanceTextureSize))
		{
			// Visual assert on overflow due to r.Lumen.RadianceCache.HardwareRayTracing.TemporaryBufferAllocationDownsampleFactor
			Lighting = float3(0, 10000, 0) * View.PreExposure;
		}

		{
			for (uint Y = 0; Y < UpsampleFactor; Y++)
			for (uint X = 0; X < UpsampleFactor; X++)
			{
				RWRadianceProbeAtlasTexture[ProbeAtlasBaseCoord + uint2(X, Y)] = Lighting;
			}
		}

		float HitDistance = Data.a;

		for (uint Y = 0; Y < UpsampleFactor; Y++)
		for (uint X = 0; X < UpsampleFactor; X++)
		{
			RWDepthProbeAtlasTexture[ProbeAtlasBaseCoord + uint2(X, Y)] = HitDistance;
		}
	}
	else
	{
		uint DownsampleFactor = TraceResolution / RadianceProbeResolution;
		uint WriteTileSize = RADIANCE_CACHE_TRACE_TILE_SIZE_2D / DownsampleFactor;

		if (all(GroupThreadId.xy < WriteTileSize))
		{
			float3 Lighting = 0;

			{
				for (uint Y = 0; Y < DownsampleFactor; Y++)
				for (uint X = 0; X < DownsampleFactor; X++)
				{
					uint2 RadianceAndHitDistanceTextureIndex = WrappedTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + GroupThreadId.xy * DownsampleFactor + uint2(X, Y);
					Lighting += RadianceAndHitDistanceTexture[RadianceAndHitDistanceTextureIndex].rgb;

					if (any(RadianceAndHitDistanceTextureIndex >= RadianceAndHitDistanceTextureSize))
					{
						// Visual assert on overflow due to r.Lumen.RadianceCache.HardwareRayTracing.TemporaryBufferAllocationDownsampleFactor
						Lighting += float3(0, 10000, 0) * View.PreExposure;
					}
				}
			}

			ProbeAtlasBaseCoord += WriteTileSize * TraceTileCoord + GroupThreadId.xy;
			RWRadianceProbeAtlasTexture[ProbeAtlasBaseCoord] = Lighting / (float)(DownsampleFactor * DownsampleFactor);

			float HitDistance = MaxHalfFloat;

			for (uint Y = 0; Y < DownsampleFactor; Y++)
			for (uint X = 0; X < DownsampleFactor; X++)
			{
				uint2 RadianceAndHitDistanceTextureIndex = WrappedTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + GroupThreadId.xy * DownsampleFactor + uint2(X, Y);
				HitDistance = min(HitDistance, RadianceAndHitDistanceTexture[RadianceAndHitDistanceTextureIndex].a);
			}

			RWDepthProbeAtlasTexture[ProbeAtlasBaseCoord] = HitDistance;
		}
	}
}
