// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenSurfaceCacheSampling.ush
=============================================================================*/

#pragma once

Texture2D DirectLightingAtlas;
Texture2D IndirectLightingAtlas;
Texture2D FinalLightingAtlas;

#define FINAL_LIGHTING_ATLAS_ID 0
#define IRRADIANCE_ATLAS_ID 1
#define INDIRECT_IRRADIANCE_ATLAS_ID 2

Texture2D AlbedoAtlas;
Texture2D OpacityAtlas;
Texture2D NormalAtlas;
Texture2D EmissiveAtlas;
Texture2D DepthAtlas;

// Make blends between cards sharper
#define CARD_NORMAL_WEIGHT_CUTOFF 0.25f

#define SURFACE_CACHE_ATLAS_SAMPLER GlobalBilinearClampedSampler

// Sampling methods
#define SURFACE_CACHE_SAMPLING_METHOD_BEST_SAMPLE 0
#define SURFACE_CACHE_SAMPLING_METHOD_STOCHASTIC 1

// Debug mode, which blends all samples
#define SURFACE_CACHE_SAMPLING_REFERENCE_MODE 1

#ifndef SURFACE_CACHE_SAMPLING_METHOD
	#define SURFACE_CACHE_SAMPLING_METHOD SURFACE_CACHE_SAMPLING_METHOD_STOCHASTIC
#endif

#if ENABLE_VISUALIZE_MODE == 1
	#define VISUALIZE_MODE_ALBEDO 1
	#define VISUALIZE_MODE_GEOMETRY_NORMALS 2
	#define VISUALIZE_MODE_NORMALS 3
	#define VISUALIZE_MODE_EMISSIVE 4
	#define VISUALIZE_MODE_OPACITY 5
	#define VISUALIZE_MODE_CARD_WEIGHTS 6
	#define VISUALIZE_MODE_DIRECT_LIGHTING 7
	#define VISUALIZE_MODE_INDIRECT_LIGHTING 8
	#define VISUALIZE_MODE_LOCAL_POSITION 9
	#define VISUALIZE_MODE_VELOCITY 10

	uint VisualizeMode;
#endif

#if SURFACE_CACHE_FEEDBACK
	RWStructuredBuffer<uint> RWSurfaceCacheFeedbackBufferAllocator;
	RWStructuredBuffer<uint2> RWSurfaceCacheFeedbackBuffer;
	uint SurfaceCacheFeedbackBufferSize;
	uint SurfaceCacheFeedbackBufferTileWrapMask;
	uint2 SurfaceCacheFeedbackBufferTileJitter;
	float SurfaceCacheFeedbackResLevelBias;
#endif


struct FLumenCardSample
{
	uint CardIndex;
	float2 PhysicalAtlasUV;
	float2 IndirectLightingPhysicalAtlasUV;
	uint2 PackedFeedback;
	bool bValid;
};

// Must match Lumen::PhysicalPageSize and Lumen::VirtualPageSize in Lumen.h
#define VIRTUAL_PAGE_SIZE			127
#define PHYSICAL_PAGE_SIZE			128
#define MIN_CARD_RESOLUTION			8
#define MIN_RES_LEVEL				3	// 2^3 = MinCardResolution
#define MAX_RES_LEVEL				11
#define SUB_ALLOCATION_RES_LEVEL	7	// = log2(PHYSICAL_PAGE_SIZE)

uint2 ResLevelXYToSizeInPages(uint2 ResLevelXY)
{
	return ResLevelXY > SUB_ALLOCATION_RES_LEVEL ? 1u << (ResLevelXY - SUB_ALLOCATION_RES_LEVEL) : 1;
}

uint2 GetSizeInPages(FLumenCardData Card, uint ResLevel)
{
	uint2 ResLevelXY = ResLevel - Card.ResLevelToResLevelXYBias;
	return ResLevelXYToSizeInPages(ResLevelXY);
}

FLumenCardSample ComputeSurfaceCacheSample(FLumenCardData Card, uint CardIndex, float2 LocalSamplePosition, float SampleRadius, bool bHiResSurface)
{
	// CardUV in [0;1]
	float2 CardUV = SamplePositonToCardUV(Card, LocalSamplePosition);

	uint2 SizeInPages = Card.SizeInPages;
	uint PageTableOffset = Card.PageTableOffset;

	if (bHiResSurface)
	{
		SizeInPages = Card.HiResSizeInPages;
		PageTableOffset = Card.HiResPageTableOffset;
	}

	uint2 PageCoord = CardUV * SizeInPages;
	uint LinearPageCoord = PageCoord.x + PageCoord.y * SizeInPages.x;

	const uint PageTableIndex = PageTableOffset + LinearPageCoord;
	const uint PageTableValue = LumenCardScene.PageTableBuffer.Load(4 * PageTableIndex);

	uint2 AtlasBias;
	AtlasBias.x = ((PageTableValue >> 0) & 0xFFF) * MIN_CARD_RESOLUTION;
	AtlasBias.y = ((PageTableValue >> 12) & 0xFFF) * MIN_CARD_RESOLUTION;

	uint2 ResLevelXY;
	ResLevelXY.x = (PageTableValue >> 24) & 0xF;
	ResLevelXY.y = (PageTableValue >> 28) & 0xF;

	// Recompute new SizeInPages, as page may be pointing to an another mip map level
	SizeInPages = ResLevelXYToSizeInPages(ResLevelXY);
	uint2 AtlasScale = ResLevelXY > SUB_ALLOCATION_RES_LEVEL ? PHYSICAL_PAGE_SIZE : (1u << ResLevelXY);

	// Sample page with a bilinear sampling border
	float2 PageUV = frac(CardUV * SizeInPages);
	float2 PhysicalAtlasUV = (PageUV * (AtlasScale - 1.0f) + AtlasBias + 0.5f) * LumenCardScene.InvPhysicalAtlasSize;
	
	// Indirect lighting cane be sampled from a downsampled atlas
	float ILFactor = LumenCardScene.IndirectLightingAtlasDownsampleFactor;
	float2 IndirectLightingPhysicalAtlasUV = (PageUV * (AtlasScale / ILFactor - 1.0f) + AtlasBias / ILFactor + 0.5f) * ILFactor * LumenCardScene.InvPhysicalAtlasSize;

	// Compute packed feedback buffer value
	uint2 PackedFeedback = 0;
	#if SURFACE_CACHE_FEEDBACK
	{
		// Compute optimal res level, based on the cone width (SampleRadius)
		float SampleResolution = max(Card.LocalExtent.x, Card.LocalExtent.y) / max(SampleRadius, 1.0f);
		uint DesiredResLevel = clamp(log2(SampleResolution) + SurfaceCacheFeedbackResLevelBias, MIN_RES_LEVEL, MAX_RES_LEVEL);

		uint2 LevelSizeInPages = GetSizeInPages(Card, DesiredResLevel);
		uint2 LocalPageCoord = CardUV * LevelSizeInPages;

		PackedFeedback.x = CardIndex | (DesiredResLevel << 24);
		PackedFeedback.y = LocalPageCoord.x + (LocalPageCoord.y << 8);
	}
	#endif

	FLumenCardSample CardSample;
	CardSample.CardIndex = CardIndex;
	CardSample.PhysicalAtlasUV = PhysicalAtlasUV;
	CardSample.IndirectLightingPhysicalAtlasUV = IndirectLightingPhysicalAtlasUV;
	CardSample.bValid = ResLevelXY.x > 0;
	CardSample.PackedFeedback = PackedFeedback;
	return CardSample;
}

struct FCardSampleReferenceAccumulator
{
	float3 LightingSum;
	float OpacitySum;
	float SampleWeightSum;
};

struct FCardSampleAccumulator
{
	// [0;1] random value for stochastic sampling
	float RandomValue;

	// Running sum of accumulated sample weights
	float SampleWeightSum;

	// Single stochastically selected sample
	FLumenCardSample CardSample;

#if SURFACE_CACHE_SAMPLING_REFERENCE_MODE
	FCardSampleReferenceAccumulator Reference;
#endif
};

void InitCardSampleAccumulator(uint2 ScreenCoord, inout FCardSampleAccumulator CardSampleAccumulator)
{
	CardSampleAccumulator.RandomValue = InterleavedGradientNoise(ScreenCoord + 0.5f, View.StateFrameIndexMod8);

#if SURFACE_CACHE_SAMPLING_REFERENCE_MODE
	CardSampleAccumulator.Reference.LightingSum = 0.0f;
	CardSampleAccumulator.Reference.OpacitySum = 0.0f;
	CardSampleAccumulator.Reference.SampleWeightSum = 0.0f;
#endif

	CardSampleAccumulator.SampleWeightSum = 0.0f;

	CardSampleAccumulator.CardSample.CardIndex = 0;
	CardSampleAccumulator.CardSample.PackedFeedback = uint2(0, 0);
	CardSampleAccumulator.CardSample.PhysicalAtlasUV = float2(0.0f, 0.0f);
	CardSampleAccumulator.CardSample.IndirectLightingPhysicalAtlasUV = float2(0.0f, 0.0f);
	CardSampleAccumulator.CardSample.bValid = false;
}

struct FSurfaceCacheSample
{
	// Surface properties
	float3 Lighting;
	float Opacity;

	uint MeshCardsIndex;
};

FSurfaceCacheSample SampleSurfaceCache(FLumenCardSample CardSample, uint AtlasId)
{
	FSurfaceCacheSample SurfaceCacheSample;
	SurfaceCacheSample.Lighting = 0.0f;
	SurfaceCacheSample.Opacity = Texture2DSampleLevel(OpacityAtlas, SURFACE_CACHE_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).x;

	if (SurfaceCacheSample.Opacity > 0.01f)
	{
		if (AtlasId == FINAL_LIGHTING_ATLAS_ID)
		{
			SurfaceCacheSample.Lighting = Texture2DSampleLevel(FinalLightingAtlas, SURFACE_CACHE_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).rgb;
		}
		else if (AtlasId == IRRADIANCE_ATLAS_ID)
		{
			float3 DirectLighting = SurfaceCacheSample.Lighting = Texture2DSampleLevel(DirectLightingAtlas, SURFACE_CACHE_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).rgb;
			float3 IndirectLighting = SurfaceCacheSample.Lighting = Texture2DSampleLevel(IndirectLightingAtlas, SURFACE_CACHE_ATLAS_SAMPLER, CardSample.IndirectLightingPhysicalAtlasUV, 0.0f).rgb;
			SurfaceCacheSample.Lighting = DirectLighting + IndirectLighting;
		}
		else // if (AtlasId == INDIRECT_IRRADIANCE_ATLAS_ID)
		{
			SurfaceCacheSample.Lighting = Texture2DSampleLevel(IndirectLightingAtlas, SURFACE_CACHE_ATLAS_SAMPLER, CardSample.IndirectLightingPhysicalAtlasUV, 0.0f).rgb;
		}

		// Debug visualization
#if ENABLE_VISUALIZE_MODE == 1
		{
			if (VisualizeMode == VISUALIZE_MODE_DIRECT_LIGHTING)
			{
				SurfaceCacheSample.Lighting = Texture2DSampleLevel(DirectLightingAtlas, SURFACE_CACHE_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).xyz;
			}
			else if (VisualizeMode == VISUALIZE_MODE_INDIRECT_LIGHTING)
			{
				SurfaceCacheSample.Lighting = Texture2DSampleLevel(IndirectLightingAtlas, SURFACE_CACHE_ATLAS_SAMPLER, CardSample.IndirectLightingPhysicalAtlasUV, 0.0f).xyz;
			}
			else if (VisualizeMode == VISUALIZE_MODE_ALBEDO)
			{
				SurfaceCacheSample.Lighting = DecodeSurfaceCacheAlbedo(Texture2DSampleLevel(AlbedoAtlas, SURFACE_CACHE_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).xyz) * View.OneOverPreExposure;
			}
			else if (VisualizeMode == VISUALIZE_MODE_NORMALS)
			{
				FLumenCardData Card = GetLumenCardData(CardSample.CardIndex);
				float3 WorldSpaceNormal = DecodeSurfaceCacheNormal(Card, Texture2DSampleLevel(NormalAtlas, SURFACE_CACHE_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).xy);
				SurfaceCacheSample.Lighting = (WorldSpaceNormal * 0.5f + 0.5f) * View.OneOverPreExposure;
			}
			else if (VisualizeMode == VISUALIZE_MODE_EMISSIVE)
			{
				SurfaceCacheSample.Lighting = Texture2DSampleLevel(EmissiveAtlas, SURFACE_CACHE_ATLAS_SAMPLER, CardSample.PhysicalAtlasUV, 0.0f).rgb;
			}
			else if (VisualizeMode == VISUALIZE_MODE_CARD_WEIGHTS)
			{
				float3 RandomColor;
				RandomColor.x = (CardSample.CardIndex % 4) / 3.0f;
				RandomColor.y = ((CardSample.CardIndex / 4) % 4) / 3.0f;
				RandomColor.z = saturate(1.0f - RandomColor.x - RandomColor.y);
				SurfaceCacheSample.Lighting = RandomColor * View.OneOverPreExposure;
			}
		}
#endif

		// Renormalize lighting values to fix darkening at the object borders (lack of border texels in surface cache)
		SurfaceCacheSample.Lighting /= SurfaceCacheSample.Opacity;
	}

	return SurfaceCacheSample;
}

void SampleLumenCard(
	float3 SamplePosition,
	float SampleRadius,
	bool bAccurateHit,
	float CardWeight,
	uint CardIndex,
	float DepthVisibilityRadius,
	bool bHiResSurface,
	uint AtlasId,
	inout FCardSampleAccumulator CardSampleAccumulator)
{
	if (CardIndex < LumenCardScene.NumCards)
	{
		FLumenCardData LumenCardData = GetLumenCardData(CardIndex);
		if (LumenCardData.bVisible)
		{
			float3 LocalSamplePosition = mul(SamplePosition - LumenCardData.Origin, LumenCardData.WorldToLocalRotation);
			if (all(abs(LocalSamplePosition) < LumenCardData.LocalExtent))
			{
				LocalSamplePosition.xy = clamp(LocalSamplePosition.xy, -LumenCardData.LocalExtent.xy, LumenCardData.LocalExtent.xy);

				FLumenCardSample CardSample = ComputeSurfaceCacheSample(LumenCardData, CardIndex, LocalSamplePosition.xy, SampleRadius, bHiResSurface);
				if (CardSample.bValid)
				{
					// Shadow map visibility
					float VisibilityWeight = 1.0f;
					{
						float2 DepthMoments = Texture2DSampleLevel(DepthAtlas, GlobalBilinearClampedSampler, CardSample.PhysicalAtlasUV, 0.0f).xy;

						// Bias a bit as SDF traces aren't super accurate
						const float RayBias = bAccurateHit ? -0.1f : -0.2f;
						const float NormalizedDistanceToHit = (-LocalSamplePosition.z / LumenCardData.LocalExtent.z) * 0.5f + 0.5f + RayBias;

						VisibilityWeight = 1.0f;
						if (NormalizedDistanceToHit > DepthMoments.x)
						{
							float Variance = abs(Square(DepthMoments.x) - DepthMoments.y);
							VisibilityWeight = saturate(Variance / (Variance + Square(NormalizedDistanceToHit - DepthMoments.x)));

							const float VisibilityCutoff = 0.15f;
							VisibilityWeight = saturate((VisibilityWeight - VisibilityCutoff) / (1.0f - VisibilityCutoff));
						}
					}

					float SampleWeight = CardWeight * VisibilityWeight;
					if (SampleWeight > 0.0f)
					{
						#if SURFACE_CACHE_SAMPLING_REFERENCE_MODE
						{
							FSurfaceCacheSample SurfaceCacheSample = SampleSurfaceCache(CardSample, AtlasId);
							CardSampleAccumulator.Reference.LightingSum += SurfaceCacheSample.Lighting * SampleWeight;
							CardSampleAccumulator.Reference.OpacitySum += SurfaceCacheSample.Opacity * SampleWeight;
							CardSampleAccumulator.Reference.SampleWeightSum += SampleWeight;
						}
						#endif

						#if SURFACE_CACHE_SAMPLING_METHOD == SURFACE_CACHE_SAMPLING_METHOD_STOCHASTIC
						{
							// Reservoir Sampling
							CardSampleAccumulator.SampleWeightSum += SampleWeight;
							if (SampleWeight / CardSampleAccumulator.SampleWeightSum >= CardSampleAccumulator.RandomValue)
							{
								CardSampleAccumulator.CardSample = CardSample;
							}
						}
						#elif SURFACE_CACHE_SAMPLING_METHOD == SURFACE_CACHE_SAMPLING_METHOD_BEST_SAMPLE
						{
							// Pick max weight
							if (SampleWeight > CardSampleAccumulator.SampleWeightSum)
							{
								CardSampleAccumulator.CardSample = CardSample;
								CardSampleAccumulator.SampleWeightSum = SampleWeight;
							}
						}
						#endif
					}
				}
			}
		}
	}
}

FSurfaceCacheSample SampleLumenMeshCards(uint2 ScreenCoord, uint SceneInstanceIndex, float3 SamplePosition, float3 SampleNormal, float SampleRadius, bool bAccurateHit, float CardInterpolateDepthVisibilityRadius, bool bHiResSurface, uint AtlasId)
{
	FSurfaceCacheSample SurfaceCacheSample;
	SurfaceCacheSample.Lighting = float3(0.0f, 0.0f, 0.0f);
	SurfaceCacheSample.Opacity = 1.0f;
	SurfaceCacheSample.MeshCardsIndex = LumenCardScene.SceneInstanceIndexToMeshCardsIndexBuffer.Load(4 * SceneInstanceIndex);

	if (SurfaceCacheSample.MeshCardsIndex < LumenCardScene.NumMeshCards)
	{
		FLumenMeshCardsData MeshCardsData = GetLumenMeshCardsData(SurfaceCacheSample.MeshCardsIndex);

		float3 LocalSamplePosition = mul(float4(SamplePosition, 1.0f), MeshCardsData.WorldToLocal).xyz;
		float3 LocalSampleNormal = normalize(mul(float4(SampleNormal, 0.0f), transpose(MeshCardsData.LocalToWorld)).xyz);

		uint CardMask = 0;
		float3 AxisWeights = LocalSampleNormal * LocalSampleNormal;

		// Pick cards by angle
		if (AxisWeights.x > CARD_NORMAL_WEIGHT_CUTOFF * CARD_NORMAL_WEIGHT_CUTOFF)
		{
			CardMask |= MeshCardsData.CardLookup[LocalSampleNormal.x < 0.0f ? 0 : 1];
		}
		if (AxisWeights.y > CARD_NORMAL_WEIGHT_CUTOFF * CARD_NORMAL_WEIGHT_CUTOFF)
		{
			CardMask |= MeshCardsData.CardLookup[LocalSampleNormal.y < 0.0f ? 2 : 3];
		}
		if (AxisWeights.z > CARD_NORMAL_WEIGHT_CUTOFF * CARD_NORMAL_WEIGHT_CUTOFF)
		{
			CardMask |= MeshCardsData.CardLookup[LocalSampleNormal.z < 0.0f ? 4 : 5];
		}

		// Cull cards by AABB
		{
			uint CulledCardMask = 0;
			while (CardMask != 0)
			{
				const uint NextBitIndex = firstbitlow(CardMask);
				const uint NextBitMask = 1u << NextBitIndex;
				CardMask ^= NextBitMask;

				uint CardIndex = MeshCardsData.CardOffset + NextBitIndex;
				FLumenCardData LumenCardData = GetLumenCardData(CardIndex);

				if (all(abs(LocalSamplePosition - LumenCardData.MeshCardsBoundsCenter) < LumenCardData.MeshCardsBoundsExtent))
				{
					CulledCardMask |= NextBitMask;
				}
			}
			CardMask = CulledCardMask;
		}

		FCardSampleAccumulator CardSampleAccumulator;
		InitCardSampleAccumulator(ScreenCoord, CardSampleAccumulator);

		// Sample cards
		while (CardMask != 0)
		{
			const uint NextBitIndex = firstbitlow(CardMask);
			CardMask ^= 1u << NextBitIndex;

			uint CardIndex = MeshCardsData.CardOffset + NextBitIndex;
			FLumenCardData LumenCardData = GetLumenCardData(CardIndex);
			if (LumenCardData.bVisible)
			{
				const float3x3 LocalToWorld = transpose(LumenCardData.WorldToLocalRotation);
				float NormalWeight = saturate(dot(SampleNormal, LocalToWorld[2].xyz));
				NormalWeight = (NormalWeight - CARD_NORMAL_WEIGHT_CUTOFF) / (1.0f - CARD_NORMAL_WEIGHT_CUTOFF);

				SampleLumenCard(
					SamplePosition,
					SampleRadius,
					bAccurateHit,
					NormalWeight,
					CardIndex,
					CardInterpolateDepthVisibilityRadius,
					bHiResSurface,
					AtlasId,
					CardSampleAccumulator);
			}
		}

		if (CardSampleAccumulator.CardSample.bValid)
		{
			SurfaceCacheSample = SampleSurfaceCache(CardSampleAccumulator.CardSample, AtlasId);
		}

		#if SURFACE_CACHE_SAMPLING_REFERENCE_MODE
		{
			if (CardSampleAccumulator.Reference.SampleWeightSum > 0.0f)
			{
				SurfaceCacheSample.Lighting = CardSampleAccumulator.Reference.LightingSum / CardSampleAccumulator.Reference.SampleWeightSum;
				SurfaceCacheSample.Opacity = CardSampleAccumulator.Reference.OpacitySum / CardSampleAccumulator.Reference.SampleWeightSum;
			}
		}
		#endif

		#if SURFACE_CACHE_FEEDBACK
		{
			// Write every n-th element
			if (all((ScreenCoord & SurfaceCacheFeedbackBufferTileWrapMask) == SurfaceCacheFeedbackBufferTileJitter)
				&& SurfaceCacheFeedbackBufferSize > 0
				&& CardSampleAccumulator.SampleWeightSum > 0.1f)
			{
				uint WriteOffset = 0;
				InterlockedAdd(RWSurfaceCacheFeedbackBufferAllocator[0], 1, WriteOffset);

				if (WriteOffset < SurfaceCacheFeedbackBufferSize)
				{
					RWSurfaceCacheFeedbackBuffer[WriteOffset] = CardSampleAccumulator.CardSample.PackedFeedback;
				}
			}
		}
		#endif

		// Debug visualization
		#if ENABLE_VISUALIZE_MODE == 1
		{
			if (VisualizeMode == VISUALIZE_MODE_GEOMETRY_NORMALS)
			{
				SurfaceCacheSample.Lighting = (SampleNormal * 0.5f + 0.5f) * View.OneOverPreExposure;
				SurfaceCacheSample.Opacity = 1.0f;
			}
			else if (VisualizeMode == VISUALIZE_MODE_OPACITY)
			{
				SurfaceCacheSample.Lighting = SurfaceCacheSample.Opacity * View.OneOverPreExposure;
				SurfaceCacheSample.Opacity = 1.0f;
			}
		}
		#endif
	}

	return SurfaceCacheSample;
}